{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Orchestr8?","text":"<p>Orchestr8 is a versatile collection of independent components crafted to simplify task automation, particularly for AI workflows.</p> <p>It offers a suite of simple, self-documenting components, providing functionalities like code/command execution across host and isolated environments, version control integration, authentication management and schema/definition generation &amp; input validation from types. Each component is independent and incrementally adoptable, so you can use them on their own or in combination with any other library.</p> <p>These components can also be utilised in AI agent workflows for file system tracking, seamless third-party service authentication, function-calling automation, and code/command/function-call execution in host or isolated environments.</p> <p>Orchestr8 is open source, free to use, and made with \ud83e\udde1 by synacktra.</p> <p> Star the Repo  Tutorial  Cookbooks</p>"},{"location":"installation/","title":"Installing Orchestr8","text":"<p>Orchestr8 requires Python 3.9 or greater, and is tested on all major Python versions and operating systems.</p> pipuv <pre><code>pip install orchestr8\n</code></pre> <pre><code>uv pip install orchestr8\n</code></pre> <p>Upgrade to the latest released version at any time:</p> pipuv <pre><code>pip install -U orchestr8\n</code></pre> <pre><code>uv pip install -U orchestr8\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional dependencies","text":"<p>Some components has their own dependencies that are not installed by default. If you wish to use all the components, you can install it through:</p> pipuv <pre><code>pip install orchestr8[all]\n</code></pre> <pre><code>uv pip install orchestr8[all]\n</code></pre> <p>If you wish to use particular components, you can install them by providing their module names as extra:</p> <p>For the <code>adapter</code> module:</p> pipuv <pre><code>pip install orchestr8[adapter]\n</code></pre> <pre><code>uv pip install orchestr8[adapter]\n</code></pre> <p>For the <code>execution-runtime</code> module:</p> pipuv <pre><code>pip install orchestr8[execution-runtime]\n</code></pre> <pre><code>uv pip install orchestr8[execution-runtime]\n</code></pre> <p>For the <code>sandbox-client</code> module:</p> pipuv <pre><code>pip install orchestr8[sandbox-client]\n</code></pre> <pre><code>uv pip install orchestr8[sandbox-client]\n</code></pre> <p>For the <code>shell</code> module:</p> pipuv <pre><code>pip install orchestr8[shell]\n</code></pre> <pre><code>uv pip install orchestr8[shell]\n</code></pre>"},{"location":"installation/#third-party-tool-dependencies","title":"Third party tool dependencies","text":"<p>Few components require third party tool dependencies to work. These tools must be installed separately.</p> <ul> <li><code>DirectoryTracker</code> requires <code>git</code> for version control, you can download it from here</li> <li><code>OAuthFlow</code> requires <code>mkcert</code> for setting up local redirect server, refer here for installation instructions</li> <li><code>SandboxClient</code>, <code>IsolatedShell</code> and <code>IsolatedRuntime</code> depends on <code>docker</code>, refer here for installation instructions</li> </ul>"},{"location":"api_reference/adapter/","title":"orchestr8.adapter","text":""},{"location":"api_reference/adapter/#baseadapter","title":"BaseAdapter","text":"<p>Base class to be inherited by all adapters.</p> Source code in <code>orchestr8/adapter/base.py</code> <pre><code>class BaseAdapter:\n    \"\"\"Base class to be inherited by all adapters.\"\"\"\n\n    def __new__(cls, *args: Any, **kwargs: Any) -&gt; BaseAdapter:\n        if cls is BaseAdapter:\n            raise TypeError(\"BaseAdapter cannot be instantiated directly\")\n        return super().__new__(cls)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Name of the adapted object.\"\"\"\n        raise NotImplementedError(\"Parent class must implemented this property\")\n\n    @property\n    def description(self) -&gt; str | None:\n        \"\"\"Description of the adapted object.\"\"\"\n        raise NotImplementedError(\"Parent class must implemented this property\")\n\n    @property\n    def schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Get the JSON schema for the adapted object.\"\"\"\n        raise NotImplementedError(\"Parent class must implemented this property\")\n\n    @property\n    def openai_schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Schema of the function in OpenAI function calling format.\"\"\"\n        return to_openai_function_calling_format(self.name, self.schema)\n\n    @property\n    def anthropic_schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Schema of the function in Anthropic function calling format.\"\"\"\n        return to_anthropic_function_calling_format(self.name, self.schema)\n\n    @property\n    def gemini_schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Schema of the function in Gemini function calling format.\"\"\"\n        return to_gemini_function_calling_format(self.name, self.schema)\n\n    def validate_input(self, input: str | Dict[str, Any], **kwargs: Any) -&gt; Any:  # noqa: A002\n        \"\"\"\n        Validate the input against the schema of the function.\n\n        Args:\n            input: The JSON value or dictionary object to validate.\n            kwargs: Additional keyword arguments.\n\n        Returns:\n            The validated input.\n        \"\"\"\n        raise NotImplementedError(\"Parent class must implemented this method\")\n</code></pre>"},{"location":"api_reference/adapter/#orchestr8.adapter.base.BaseAdapter.anthropic_schema","title":"<code>anthropic_schema: Dict[str, Any]</code>  <code>property</code>","text":"<p>Schema of the function in Anthropic function calling format.</p>"},{"location":"api_reference/adapter/#orchestr8.adapter.base.BaseAdapter.description","title":"<code>description: str | None</code>  <code>property</code>","text":"<p>Description of the adapted object.</p>"},{"location":"api_reference/adapter/#orchestr8.adapter.base.BaseAdapter.gemini_schema","title":"<code>gemini_schema: Dict[str, Any]</code>  <code>property</code>","text":"<p>Schema of the function in Gemini function calling format.</p>"},{"location":"api_reference/adapter/#orchestr8.adapter.base.BaseAdapter.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Name of the adapted object.</p>"},{"location":"api_reference/adapter/#orchestr8.adapter.base.BaseAdapter.openai_schema","title":"<code>openai_schema: Dict[str, Any]</code>  <code>property</code>","text":"<p>Schema of the function in OpenAI function calling format.</p>"},{"location":"api_reference/adapter/#orchestr8.adapter.base.BaseAdapter.schema","title":"<code>schema: Dict[str, Any]</code>  <code>property</code>","text":"<p>Get the JSON schema for the adapted object.</p>"},{"location":"api_reference/adapter/#orchestr8.adapter.base.BaseAdapter.validate_input","title":"<code>validate_input</code>","text":"<p>Validate the input against the schema of the function.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str | Dict[str, Any]</code> <p>The JSON value or dictionary object to validate.</p> required <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The validated input.</p> Source code in <code>orchestr8/adapter/base.py</code> <pre><code>def validate_input(self, input: str | Dict[str, Any], **kwargs: Any) -&gt; Any:  # noqa: A002\n    \"\"\"\n    Validate the input against the schema of the function.\n\n    Args:\n        input: The JSON value or dictionary object to validate.\n        kwargs: Additional keyword arguments.\n\n    Returns:\n        The validated input.\n    \"\"\"\n    raise NotImplementedError(\"Parent class must implemented this method\")\n</code></pre>"},{"location":"api_reference/adapter/#structadapter","title":"StructAdapter","text":"<p>A wrapper around pydantic's <code>TypeAdapter</code> for schema and definition generation with capability to validate input from python or JsON object.</p> <p>Structured types such as Pydantic Models, TypedDict, dataclasses, etc. are supported.</p> <p>Provides: - Code definition extraction. - Dynamic schema generation in standard and function-calling formats such as OpenAI, Anthropic, and Gemini. - Extraction of docstring metadata for populating schema. - Automatic validation of python or JsON input against the schema.</p> <p>Useful for schema-driven representations of complex types for use in function calling, serialization, and documentation contexts.</p> <pre><code>from typing_extensions import TypedDict\nfrom orchestract.adapter.struct import StructAdapter\n\nclass User(TypedDict): # Can be pydantic model or dataclass\n    id: str\n    role: Literal[\"admin\", \"user\"]\n\n# Create adapter\nstruct = StructAdapter(User)\n\n# Normal invocation\nstruct(id=\"user123\", role=\"user\") # returns: {\"id\": \"user123\", \"role\": \"user\"}\n\n# Access adapter properties\nprint(f\"Struct name: {struct.name}\")\nprint(f\"Struct description: {struct.description}\")\nprint(f\"Struct docstring: {struct.docstring}\")\nprint(f\"Struct definition: {struct.definition}\")\nprint(f\"Struct schema: {struct.schema}\")\nprint(f\"Struct OpenAI schema: {struct.openai_schema}\")\nprint(f\"Struct Anthropic schema: {struct.anthropic_schema}\")\nprint(f\"Struct Gemini schema: {struct.gemini_schema}\")\n\n# Validate python input\nstruct.validate_input({\"id\": \"user123\", \"role\": \"user\"})\n\n# Validate JSON input\nstruct.validate_input('{\"id\": \"user123\", \"role\": \"user\"}')\n</code></pre> Source code in <code>orchestr8/adapter/struct.py</code> <pre><code>class StructAdapter(Generic[T], BaseAdapter):\n    \"\"\"\n    A wrapper around pydantic's `TypeAdapter` for schema and definition generation with capability to\n    validate input from python or JsON object.\n\n    Structured types such as Pydantic Models, TypedDict, dataclasses, etc. are supported.\n\n    Provides:\n    - Code definition extraction.\n    - Dynamic schema generation in standard and function-calling formats such as OpenAI, Anthropic, and Gemini.\n    - Extraction of docstring metadata for populating schema.\n    - Automatic validation of python or JsON input against the schema.\n\n    Useful for schema-driven representations of complex types for use in function calling,\n    serialization, and documentation contexts.\n\n    ```python\n    from typing_extensions import TypedDict\n    from orchestract.adapter.struct import StructAdapter\n\n    class User(TypedDict): # Can be pydantic model or dataclass\n        id: str\n        role: Literal[\"admin\", \"user\"]\n\n    # Create adapter\n    struct = StructAdapter(User)\n\n    # Normal invocation\n    struct(id=\"user123\", role=\"user\") # returns: {\"id\": \"user123\", \"role\": \"user\"}\n\n    # Access adapter properties\n    print(f\"Struct name: {struct.name}\")\n    print(f\"Struct description: {struct.description}\")\n    print(f\"Struct docstring: {struct.docstring}\")\n    print(f\"Struct definition: {struct.definition}\")\n    print(f\"Struct schema: {struct.schema}\")\n    print(f\"Struct OpenAI schema: {struct.openai_schema}\")\n    print(f\"Struct Anthropic schema: {struct.anthropic_schema}\")\n    print(f\"Struct Gemini schema: {struct.gemini_schema}\")\n\n    # Validate python input\n    struct.validate_input({\"id\": \"user123\", \"role\": \"user\"})\n\n    # Validate JSON input\n    struct.validate_input('{\"id\": \"user123\", \"role\": \"user\"}')\n    ```\n    \"\"\"\n\n    ref_type: Literal[\"function\", \"class\"] | None = \"class\"\n    validate_ref = lambda c, r: isclass(r)\n\n    def __init__(self, __obj: Type[T]) -&gt; None:\n        \"\"\"\n        Args:\n            __obj: The structured type to create adapter from\n\n        Raises:\n            ValueError: If object is of not class type\n        \"\"\"\n        if not self.validate_ref(__obj):\n            raise ValueError(f\"Expected a {self.ref_type!r}\")\n        self.__ref = __obj\n        self.__name = self.__ref.__name__\n\n        from docstring_parser import parse\n        from pydantic.type_adapter import TypeAdapter\n\n        self.__docstring = parse(self.__ref.__doc__ or \"\")\n        self.__adapter = TypeAdapter(self.__ref)\n        self.__description = build_description(self.__docstring)\n        self.__definition: str | None = None\n        self.__schema: Dict[str, Any] | None = None\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; T:\n        return self.__ref(*args, **kwargs)\n\n    @property\n    def name(self) -&gt; str:\n        return self.__name\n\n    @property\n    def description(self) -&gt; str | None:\n        return self.__description or None\n\n    @property\n    def docstring(self) -&gt; Docstring:\n        return self.__docstring\n\n    @property\n    def definition(self) -&gt; str:\n        \"\"\"Code definition\"\"\"\n        if self.__definition is None:\n            self.__definition = get_code_definition(self.__ref, type=self.ref_type)\n        return self.__definition\n\n    @property\n    def schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Schema in standard format.\"\"\"\n        if self.__schema is None:\n            base_schema = self.__adapter.json_schema()\n            if \"$defs\" in base_schema:\n                from jsonref import replace_refs  # type: ignore[import-untyped]\n\n                base_schema = replace_refs(base_schema, lazy_load=False)\n                _ = base_schema.pop(\"$defs\", None)\n            self.__schema = update_object_schema(self.__ref, base_schema, self.__docstring)\n        return self.__schema\n\n    def validate_input(self, input: Dict[str, Any] | str, *, strict: bool | None = None, **kwargs: Any) -&gt; T:  # noqa: A002\n        \"\"\"\n        Validate the input against the schema.\n\n        Args:\n            input: The dictionary object or JSON string to validate.\n            strict: Whether to perform strict validation.\n            kwargs: Additional keyword arguments to pass to the TypeAdapter's validate method.\n\n        Returns:\n            The validated input.\n        \"\"\"\n        if isinstance(input, str):\n            return self.__adapter.validate_json(input, strict=strict, **kwargs)\n        return self.__adapter.validate_python(input, strict=strict, **kwargs)\n</code></pre>"},{"location":"api_reference/adapter/#orchestr8.adapter.struct.StructAdapter.definition","title":"<code>definition: str</code>  <code>property</code>","text":"<p>Code definition</p>"},{"location":"api_reference/adapter/#orchestr8.adapter.struct.StructAdapter.schema","title":"<code>schema: Dict[str, Any]</code>  <code>property</code>","text":"<p>Schema in standard format.</p>"},{"location":"api_reference/adapter/#orchestr8.adapter.struct.StructAdapter.validate_input","title":"<code>validate_input</code>","text":"<p>Validate the input against the schema.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Dict[str, Any] | str</code> <p>The dictionary object or JSON string to validate.</p> required <code>strict</code> <code>bool | None</code> <p>Whether to perform strict validation.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the TypeAdapter's validate method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>The validated input.</p> Source code in <code>orchestr8/adapter/struct.py</code> <pre><code>def validate_input(self, input: Dict[str, Any] | str, *, strict: bool | None = None, **kwargs: Any) -&gt; T:  # noqa: A002\n    \"\"\"\n    Validate the input against the schema.\n\n    Args:\n        input: The dictionary object or JSON string to validate.\n        strict: Whether to perform strict validation.\n        kwargs: Additional keyword arguments to pass to the TypeAdapter's validate method.\n\n    Returns:\n        The validated input.\n    \"\"\"\n    if isinstance(input, str):\n        return self.__adapter.validate_json(input, strict=strict, **kwargs)\n    return self.__adapter.validate_python(input, strict=strict, **kwargs)\n</code></pre>"},{"location":"api_reference/adapter/#functionadapter","title":"FunctionAdapter","text":"<p>A specialized adapter for Python functions, extending StructAdapter to handle function-specific type hints.</p> <p>Provides: - Function code definition extraction - Dynamic schema generation for function signatures. - Extraction of docstring metadata for populating schema. - Automatic validation of python or JsON input against the schema.</p> <p>Enables schema-driven representations of functions for function calling, serialization, and documentation purposes.</p> <pre><code>from orchestr8.adapter.function import FunctionAdapter\n\ndef create_user(id: str, role: Literal[\"admin\", \"user\"]) -&gt; bool:\n    \"\"\"\n    Creates a new user with the given ID and role.\n\n    :param id: The ID of the user to create.\n    :param role: The role of the user to create.\n    \"\"\"\n\n# Create adapter\nfn = FunctionAdapter(create_user)\n\n# Normal invocation\nfn(id=\"user123\", role=\"user\")\n\n# Access function properties\nprint(f\"Function name: {fn.name}\")\nprint(f\"Function description: {fn.description}\")\nprint(f\"Function docstring: {fn.docstring}\")\nprint(f\"Function definition: {fn.definition}\")\nprint(f\"Function schema: {fn.schema}\")\nprint(f\"Function OpenAI schema: {fn.openai_schema}\")\nprint(f\"Function Anthropic schema: {fn.anthropic_schema}\")\nprint(f\"Function Gemini schema: {fn.gemini_schema}\")\n\n# Validate python input\nfn.validate_input({\"id\": \"user123\", \"role\": \"user\"})\n\n# Validate JSON input\nfn.validate_input('{\"id\": \"user123\", \"role\": \"user\"}')\n</code></pre> Source code in <code>orchestr8/adapter/function.py</code> <pre><code>class FunctionAdapter(StructAdapter[T_Retval], Generic[P_Spec, T_Retval]):  # type: ignore[misc]\n    \"\"\"\n    A specialized adapter for Python functions, extending StructAdapter to handle function-specific type hints.\n\n    Provides:\n    - Function code definition extraction\n    - Dynamic schema generation for function signatures.\n    - Extraction of docstring metadata for populating schema.\n    - Automatic validation of python or JsON input against the schema.\n\n    Enables schema-driven representations of functions for function calling, serialization, and documentation purposes.\n\n    ```python\n    from orchestr8.adapter.function import FunctionAdapter\n\n    def create_user(id: str, role: Literal[\"admin\", \"user\"]) -&gt; bool:\n        \\\"\"\"\n        Creates a new user with the given ID and role.\n\n        :param id: The ID of the user to create.\n        :param role: The role of the user to create.\n        \\\"\"\"\n\n    # Create adapter\n    fn = FunctionAdapter(create_user)\n\n    # Normal invocation\n    fn(id=\"user123\", role=\"user\")\n\n    # Access function properties\n    print(f\"Function name: {fn.name}\")\n    print(f\"Function description: {fn.description}\")\n    print(f\"Function docstring: {fn.docstring}\")\n    print(f\"Function definition: {fn.definition}\")\n    print(f\"Function schema: {fn.schema}\")\n    print(f\"Function OpenAI schema: {fn.openai_schema}\")\n    print(f\"Function Anthropic schema: {fn.anthropic_schema}\")\n    print(f\"Function Gemini schema: {fn.gemini_schema}\")\n\n    # Validate python input\n    fn.validate_input({\"id\": \"user123\", \"role\": \"user\"})\n\n    # Validate JSON input\n    fn.validate_input('{\"id\": \"user123\", \"role\": \"user\"}')\n    ```\n    \"\"\"\n\n    ref_type = \"function\"\n    validate_ref = lambda c, r: isfunction(r)\n\n    def __init__(self, __fn: Callable[P_Spec, T_Retval]) -&gt; None:  # type: ignore[valid-type]\n        \"\"\"\n        Args:\n            __fn: The function to create adapter from\n\n        Raises:\n            ValueError: If __fn is not a valid function\n        \"\"\"\n        super().__init__(__fn)  # type: ignore[arg-type]\n\n    def __call__(self, *args: P_Spec.args, **kwargs: P_Spec.kwargs) -&gt; T_Retval:  # type: ignore[name-defined]\n        return super().__call__(*args, **kwargs)\n</code></pre>"},{"location":"api_reference/adapter/#adapt-decorator","title":"<code>@adapt</code> decorator","text":"<p>Create an adapter from a function or structured type such as Pydantic Model, TypedDict, dataclass, etc.</p> <pre><code>from orchestr8.adapter import adapt\nfrom typing_extensions import TypedDict\nfrom pydantic import BaseModel\n\n@adapt\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"\n    Add two numbers together.\n\n    :param a: The first number to add.\n    :param b: The second number to add.\n    \"\"\"\n    return a + b\n\n@adapt\nclass User(TypedDict):\n    id: str\n    role: Literal[\"admin\", \"user\"]\n</code></pre> Source code in <code>orchestr8/adapter/__init__.py</code> <pre><code>def adapt(__obj: Any) -&gt; Any:\n    \"\"\"\n    Create an adapter from a function or structured type such as\n    Pydantic Model, TypedDict, dataclass, etc.\n\n    ```python\n    from orchestr8.adapter import adapt\n    from typing_extensions import TypedDict\n    from pydantic import BaseModel\n\n    @adapt\n    def add(a: int, b: int) -&gt; int:\n        \\\"\"\"\n        Add two numbers together.\n\n        :param a: The first number to add.\n        :param b: The second number to add.\n        \\\"\"\"\n        return a + b\n\n    @adapt\n    class User(TypedDict):\n        id: str\n        role: Literal[\"admin\", \"user\"]\n    ```\n    \"\"\"\n    if isfunction(__obj):\n        return FunctionAdapter(__obj)\n    elif isclass(__obj):\n        return StructAdapter(__obj)\n    raise ValueError(f\"Expected a function or class, got {type(__obj)} type\")\n</code></pre>"},{"location":"api_reference/directory-tracker/","title":"orchestr8.directory_tracker","text":"<p>A Git-based directory tracker that provides version control functionality.</p> <p>This class wraps Git commands to provide simple version control capabilities, including tracking changes, committing modifications, and undoing uncommitted changes. Supports large files through Git LFS when directory size exceeds a configurable limit.</p> <pre><code># Initialize tracker for a specific directory\ntracker = DirectoryTracker(\n    path=\"path/to/directory\",\n    use_lfs_after_size=200 # Use Git LFS if directory size exceeds 200MB\n)\n\n# Check if directory is being tracked\nprint(tracker.is_tracking)\n\n# Check for changes\nprint(tracker.has_changes)\n\n# Commit all changes\ntracker.commit(\"Updated files\")\n\n# Undo all uncommited changes if needed\ntracker.undo()\n\n# Delete the .git directory\ntracker.delete()\n\n# Initialize tracking explicitly\ntracker.initialize()\n</code></pre> Source code in <code>orchestr8/directory_tracker.py</code> <pre><code>class DirectoryTracker(Logger):\n    \"\"\"\n    A Git-based directory tracker that provides version control functionality.\n\n    This class wraps Git commands to provide simple version control capabilities,\n    including tracking changes, committing modifications, and undoing uncommitted changes.\n    Supports large files through Git LFS when directory size exceeds a configurable limit.\n\n    ```python\n    # Initialize tracker for a specific directory\n    tracker = DirectoryTracker(\n        path=\"path/to/directory\",\n        use_lfs_after_size=200 # Use Git LFS if directory size exceeds 200MB\n    )\n\n    # Check if directory is being tracked\n    print(tracker.is_tracking)\n\n    # Check for changes\n    print(tracker.has_changes)\n\n    # Commit all changes\n    tracker.commit(\"Updated files\")\n\n    # Undo all uncommited changes if needed\n    tracker.undo()\n\n    # Delete the .git directory\n    tracker.delete()\n\n    # Initialize tracking explicitly\n    tracker.initialize()\n    ```\n    \"\"\"\n\n    def __init__(self, path: str | Path | None = None, *, use_lfs_after_size: int = 200) -&gt; None:\n        \"\"\"\n        Args:\n            path: Directory path to use. If None, uses current working directory\n            use_lfs_after_size: Maximum directory size in MB before enabling Git LFS\n\n        Raises:\n            Exception: If git is not found or unable to use git in the given directory\n        \"\"\"\n        if path:\n            self.__path = Path(path).expanduser().resolve().absolute()\n            if not self.__path.is_dir():\n                raise NotADirectoryError(f\"Directory {str(self.__path)!r} doesn't exists.\")\n        else:\n            self.__path = Path.cwd()\n\n        if not shutil.which(\"git\"):\n            raise FileNotFoundError(\"git command not found. Please install it.\")\n\n        self.__shell = Shell(workdir=self.__path, raise_on_non_zero=True)\n        self.__use_lfs_after_size = use_lfs_after_size\n        if os.name == \"nt\" and \"SHELL\" not in os.environ:\n            self._rm_dot_git_cmd = [\"Remove-Item\", \"-Path\", \".git\", \"-Recurse\", \"-Force\"]\n        else:\n            self._rm_dot_git_cmd = [\"rm\", \"-rf\", \".git\"]\n\n        self.initialize()\n\n    @property\n    def path(self) -&gt; Path:\n        \"\"\"The directory path.\"\"\"\n        return self.__path\n\n    @property\n    def shell(self) -&gt; Shell:\n        \"\"\"The shell instance.\"\"\"\n        return self.__shell\n\n    @property\n    def is_tracking(self) -&gt; bool:\n        \"\"\"\n        Check if git tracking is enabled for the directory.\n\n        Returns:\n            True if the directory is being tracked (has .git directory), False otherwise\n        \"\"\"\n        return (self.__path / \".git\").is_dir()\n\n    @property\n    def has_changes(self) -&gt; bool:\n        \"\"\"\n        Check if there are any uncommitted changes in the tracked directory.\n\n        Returns:\n            True if there are uncommitted changes, False otherwise\n\n        Raises:\n            LookupError: If `.git` directory is not found\n        \"\"\"\n        self.raise_if_not_tracking()\n        self.logger.info(\"Checking for uncommitted changes\")\n        return bool(self.__shell.run(\"git\", \"status\", \"--porcelain\"))\n\n    @property\n    def is_lfs_required(self) -&gt; bool:\n        \"\"\"\n        Check if the directory requires Git LFS.\n\n        Returns:\n            True if the directory size exceeds the configured limit, False otherwise\n        \"\"\"\n        return check_path_size_limit(self.__path, self.__use_lfs_after_size)\n\n    @property\n    def is_using_lfs(self) -&gt; bool:\n        \"\"\"\n        Check if the repository is using Git LFS.\n\n        Returns:\n            True if Git LFS is configured and initialized, False otherwise\n\n        Raises:\n            LookupError: If `.git` directory is not found\n        \"\"\"\n        self.raise_if_not_tracking()\n        return (self.__path / \".git\" / \"lfs\").is_dir()\n\n    def raise_if_not_tracking(self) -&gt; None:\n        \"\"\"\n        Raise LookUpError if the directory is not being tracked.\n        \"\"\"\n        if not self.is_tracking:\n            raise LookupError(\"Tracking has not been enabled.\")\n\n    def initialize(self) -&gt; None:\n        \"\"\"\n        Initialize tracking directory changes.\n        \"\"\"\n        if self.is_tracking and self.has_changes:\n            self.logger.warning(\"Detected uncommitted changes. Make sure to commit them.\")\n\n        commit = False\n        if not self.is_tracking:\n            self.logger.info(\"Initializing git repository\")\n            self.__shell.run(\"git\", \"init\")\n            commit = True\n        if self.is_lfs_required and not self.is_using_lfs:\n            self.logger.info(\"Installing Git LFS\")\n            self.__shell.run(\"git\", \"lfs\", \"install\")\n            commit = True\n        if commit:\n            self.commit(\"tracker init\", empty=True, bypass=True)\n\n    def commit(self, __message: str, *, empty: bool = False, bypass: bool = False) -&gt; None:\n        \"\"\"\n        Commit all changes made to the tracked directory.\n\n        Args:\n            __message: The commit message\n            empty: If True, create a commit even if there are no changes\n            bypass: If True, bypass pre-commit and commit-msg hooks\n\n        Raises:\n            LookupError: If `.git` directory is not found\n        \"\"\"\n        self.raise_if_not_tracking()\n\n        self.logger.info(\"Staging all changes\")\n        self.__shell.run(\"git\", \"add\", \".\")\n\n        commit_args = [\"-m\", json_dumps(f\"[{get_timestamp()}] {__message}\")]\n        if empty:\n            commit_args.append(\"--allow-empty\")\n            self.logger.info(\"Creating an empty commit\")\n        else:\n            self.logger.info(\"Persisting uncommitted changes\")\n        if bypass:\n            commit_args.append(\"--no-verify\")\n        self.__shell.run(\"git\", \"commit\", *commit_args)\n\n    def undo(self) -&gt; None:\n        \"\"\"\n        Undo all uncommitted changes in the tracked directory.\n\n        This operation:\n        1. Removes untracked files and directories\n        2. Resets all tracked files to their last committed state\n\n        Raises:\n            LookupError: If `.git` directory is not found\n        \"\"\"\n        self.raise_if_not_tracking()\n        self.logger.info(\"Removing untracked files and directories\")\n        self.__shell.run(\"git\", \"clean\", \"-fd\")\n        self.logger.info(\"Resetting all tracked files to their last committed state\")\n        self.__shell.run(\"git\", \"reset\", \"--hard\", \"HEAD\")\n\n    def delete(self, commit: bool = True) -&gt; None:\n        \"\"\"\n        Delete the .git directory.\n\n        Args:\n            commit: Whether to commit all changes before deleting\n\n        Raises:\n            LookupError: If `.git` directory is not found\n        \"\"\"\n        if commit and self.has_changes:\n            self.commit(\"tracker delete\")\n\n        self.logger.info(\"Deleting .git directory\")\n        if self.is_tracking:\n            self.__shell.run(*self._rm_dot_git_cmd)\n</code></pre>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.has_changes","title":"<code>has_changes: bool</code>  <code>property</code>","text":"<p>Check if there are any uncommitted changes in the tracked directory.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if there are uncommitted changes, False otherwise</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If <code>.git</code> directory is not found</p>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.is_lfs_required","title":"<code>is_lfs_required: bool</code>  <code>property</code>","text":"<p>Check if the directory requires Git LFS.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the directory size exceeds the configured limit, False otherwise</p>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.is_tracking","title":"<code>is_tracking: bool</code>  <code>property</code>","text":"<p>Check if git tracking is enabled for the directory.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the directory is being tracked (has .git directory), False otherwise</p>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.is_using_lfs","title":"<code>is_using_lfs: bool</code>  <code>property</code>","text":"<p>Check if the repository is using Git LFS.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if Git LFS is configured and initialized, False otherwise</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If <code>.git</code> directory is not found</p>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.path","title":"<code>path: Path</code>  <code>property</code>","text":"<p>The directory path.</p>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.shell","title":"<code>shell: Shell</code>  <code>property</code>","text":"<p>The shell instance.</p>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.commit","title":"<code>commit</code>","text":"<p>Commit all changes made to the tracked directory.</p> <p>Parameters:</p> Name Type Description Default <code>__message</code> <code>str</code> <p>The commit message</p> required <code>empty</code> <code>bool</code> <p>If True, create a commit even if there are no changes</p> <code>False</code> <code>bypass</code> <code>bool</code> <p>If True, bypass pre-commit and commit-msg hooks</p> <code>False</code> <p>Raises:</p> Type Description <code>LookupError</code> <p>If <code>.git</code> directory is not found</p> Source code in <code>orchestr8/directory_tracker.py</code> <pre><code>def commit(self, __message: str, *, empty: bool = False, bypass: bool = False) -&gt; None:\n    \"\"\"\n    Commit all changes made to the tracked directory.\n\n    Args:\n        __message: The commit message\n        empty: If True, create a commit even if there are no changes\n        bypass: If True, bypass pre-commit and commit-msg hooks\n\n    Raises:\n        LookupError: If `.git` directory is not found\n    \"\"\"\n    self.raise_if_not_tracking()\n\n    self.logger.info(\"Staging all changes\")\n    self.__shell.run(\"git\", \"add\", \".\")\n\n    commit_args = [\"-m\", json_dumps(f\"[{get_timestamp()}] {__message}\")]\n    if empty:\n        commit_args.append(\"--allow-empty\")\n        self.logger.info(\"Creating an empty commit\")\n    else:\n        self.logger.info(\"Persisting uncommitted changes\")\n    if bypass:\n        commit_args.append(\"--no-verify\")\n    self.__shell.run(\"git\", \"commit\", *commit_args)\n</code></pre>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.delete","title":"<code>delete</code>","text":"<p>Delete the .git directory.</p> <p>Parameters:</p> Name Type Description Default <code>commit</code> <code>bool</code> <p>Whether to commit all changes before deleting</p> <code>True</code> <p>Raises:</p> Type Description <code>LookupError</code> <p>If <code>.git</code> directory is not found</p> Source code in <code>orchestr8/directory_tracker.py</code> <pre><code>def delete(self, commit: bool = True) -&gt; None:\n    \"\"\"\n    Delete the .git directory.\n\n    Args:\n        commit: Whether to commit all changes before deleting\n\n    Raises:\n        LookupError: If `.git` directory is not found\n    \"\"\"\n    if commit and self.has_changes:\n        self.commit(\"tracker delete\")\n\n    self.logger.info(\"Deleting .git directory\")\n    if self.is_tracking:\n        self.__shell.run(*self._rm_dot_git_cmd)\n</code></pre>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.initialize","title":"<code>initialize</code>","text":"<p>Initialize tracking directory changes.</p> Source code in <code>orchestr8/directory_tracker.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize tracking directory changes.\n    \"\"\"\n    if self.is_tracking and self.has_changes:\n        self.logger.warning(\"Detected uncommitted changes. Make sure to commit them.\")\n\n    commit = False\n    if not self.is_tracking:\n        self.logger.info(\"Initializing git repository\")\n        self.__shell.run(\"git\", \"init\")\n        commit = True\n    if self.is_lfs_required and not self.is_using_lfs:\n        self.logger.info(\"Installing Git LFS\")\n        self.__shell.run(\"git\", \"lfs\", \"install\")\n        commit = True\n    if commit:\n        self.commit(\"tracker init\", empty=True, bypass=True)\n</code></pre>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.raise_if_not_tracking","title":"<code>raise_if_not_tracking</code>","text":"<p>Raise LookUpError if the directory is not being tracked.</p> Source code in <code>orchestr8/directory_tracker.py</code> <pre><code>def raise_if_not_tracking(self) -&gt; None:\n    \"\"\"\n    Raise LookUpError if the directory is not being tracked.\n    \"\"\"\n    if not self.is_tracking:\n        raise LookupError(\"Tracking has not been enabled.\")\n</code></pre>"},{"location":"api_reference/directory-tracker/#orchestr8.directory_tracker.DirectoryTracker.undo","title":"<code>undo</code>","text":"<p>Undo all uncommitted changes in the tracked directory.</p> <p>This operation: 1. Removes untracked files and directories 2. Resets all tracked files to their last committed state</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If <code>.git</code> directory is not found</p> Source code in <code>orchestr8/directory_tracker.py</code> <pre><code>def undo(self) -&gt; None:\n    \"\"\"\n    Undo all uncommitted changes in the tracked directory.\n\n    This operation:\n    1. Removes untracked files and directories\n    2. Resets all tracked files to their last committed state\n\n    Raises:\n        LookupError: If `.git` directory is not found\n    \"\"\"\n    self.raise_if_not_tracking()\n    self.logger.info(\"Removing untracked files and directories\")\n    self.__shell.run(\"git\", \"clean\", \"-fd\")\n    self.logger.info(\"Resetting all tracked files to their last committed state\")\n    self.__shell.run(\"git\", \"reset\", \"--hard\", \"HEAD\")\n</code></pre>"},{"location":"api_reference/execution-runtime/","title":"orchestr8.execution_runtime","text":""},{"location":"api_reference/execution-runtime/#create_project-function","title":"<code>create_project</code> function","text":"<p>Create a uv project from a python script.</p> <pre><code>create_project(\n    \"/path/to/script.py\",\n    id=\"project_id\", # Not required, defaults to script name.\n    requirements=[\"package=0.0.0\"], # Set `True` to auto generate\n)\n</code></pre> <p>Refer <code>orchestr8.execution_runtime.package_utils.generate_requirements</code> to know more about auto-generation of requirements from python source file and <code>dependency_overrides</code>.</p> <p>Parameters:</p> Name Type Description Default <code>__script</code> <code>str | Path</code> <p>The python script to create project from</p> required <code>id</code> <code>str | None</code> <p>The id to use for the project. Defaults to the script name</p> <code>None</code> <code>requirements</code> <code>List[str] | Literal[True] | None</code> <p>List of requirement strings (e.g., [\"package==1.0.0\"]) or True to auto-generate</p> <code>None</code> <code>dependency_overrides</code> <code>Dict[str, Dependency] | None</code> <p>Depedency overrides. Applicable only if requirements=True</p> <code>None</code> <code>force</code> <code>bool</code> <p>Whether to force create the project even if it's already available</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the script file is not found</p> Source code in <code>orchestr8/execution_runtime/__init__.py</code> <pre><code>def create_project(\n    __script: str | Path,\n    *,\n    id: str | None = None,  # noqa: A002\n    requirements: List[str] | Literal[True] | None = None,\n    dependency_overrides: Dict[str, Dependency] | None = None,\n    force: bool = False,\n) -&gt; None:\n    \"\"\"\n    Create a uv project from a python script.\n\n    ```python\n    create_project(\n        \"/path/to/script.py\",\n        id=\"project_id\", # Not required, defaults to script name.\n        requirements=[\"package=0.0.0\"], # Set `True` to auto generate\n    )\n    ```\n\n    Refer `orchestr8.execution_runtime.package_utils.generate_requirements` to know more\n    about auto-generation of requirements from python source file and `dependency_overrides`.\n\n    Args:\n        __script: The python script to create project from\n        id: The id to use for the project. Defaults to the script name\n        requirements: List of requirement strings (e.g., [\"package==1.0.0\"]) or True to auto-generate\n        dependency_overrides: Depedency overrides. Applicable only if requirements=True\n        force: Whether to force create the project even if it's already available\n\n    Raises:\n        FileNotFoundError: If the script file is not found\n\n    \"\"\"\n    project_id = id or Path(__script).stem\n    project_dir = RUNTIME_PROJECTS_DIR / project_id\n    if project_exists(project_id):\n        if not force:\n            raise FileExistsError(f\"Project with id {project_id!r} already exists.\" \" Use `force=True` to overwrite.\")\n        shutil.rmtree(project_dir, ignore_errors=True)\n\n    script, requirements = _validate_script_and_requirements(\n        __script, requirements=requirements, dependency_overrides=dependency_overrides\n    )\n\n    shell = Shell(workdir=RUNTIME_PROJECTS_DIR)\n\n    # Creating a new project\n    shell.run(\"uv\", \"init\", \"--vcs\", \"none\", \"--no-readme\", \"--no-workspace\", \"--no-pin-python\", project_id)\n\n    # Deleting default hello.py created by uv\n    (project_dir / \"hello.py\").unlink(missing_ok=True)\n    # Copy the script to `main.py` in the project directory\n    (project_dir / \"main.py\").write_bytes(script.read_bytes())\n\n    if requirements:\n        # Add dependencies to the project\n        shell.run(\"uv\", \"add\", \"--directory\", project_id, *requirements)\n\n        # Create a requirements.txt file for isolated runtime virtual environments\n        shell.run(\n            \"uv\",\n            \"export\",\n            \"--directory\",\n            project_id,\n            \"--no-editable\",\n            \"--no-emit-project\",\n            \"--no-header\",\n            \"--locked\",\n            \"--format\",\n            \"requirements-txt\",\n            \"-o\",\n            \"requirements.txt\",\n        )\n</code></pre>"},{"location":"api_reference/execution-runtime/#create_execution_runtime-function","title":"<code>create_execution_runtime</code> function","text":"<p>Create execution runtime instance for running Python scripts and created projects.</p> <pre><code>runtime = create_execution_runtime(isolate=True, python_tag=\"3.10-alpine3.20\")\n\n# Run a script with auto-generated requirements\noutput = runtime.run_script('script1.py', '-p1', 'value1', requirements=True)\n\n# Run a script with pre-defined requirements\noutput = runtime.run_script('script2.py', requirements=[\"requests==2.25.1\"])\n\n# Run a created project\noutput = runtime.run_project('project_id', '--param1', 'value1')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>isolate</code> <code>bool</code> <p>Whether to isolate the runtime. Defaults to False</p> <code>False</code> <code>python_tag</code> <code>str | None</code> <p>Python image tag. Defaults to 3.10-alpine3.20. Applicable, if <code>isolate is True</code></p> <code>None</code> <code>docker_config</code> <code>Any</code> <p>Docker client configuration. Applicable, if <code>isolate is True</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>ExecutionRuntime | IsolatedExecutionRuntime</code> <p>Runtime instance</p> Source code in <code>orchestr8/execution_runtime/__init__.py</code> <pre><code>def create_execution_runtime(\n    isolate: bool = False, python_tag: str | None = None, **docker_config: Any\n) -&gt; ExecutionRuntime | IsolatedExecutionRuntime:\n    \"\"\"\n    Create execution runtime instance for running Python scripts and created projects.\n\n    ```python\n    runtime = create_execution_runtime(isolate=True, python_tag=\"3.10-alpine3.20\")\n\n    # Run a script with auto-generated requirements\n    output = runtime.run_script('script1.py', '-p1', 'value1', requirements=True)\n\n    # Run a script with pre-defined requirements\n    output = runtime.run_script('script2.py', requirements=[\"requests==2.25.1\"])\n\n    # Run a created project\n    output = runtime.run_project('project_id', '--param1', 'value1')\n    ```\n\n    Args:\n        isolate: Whether to isolate the runtime. Defaults to False\n        python_tag: Python image tag. Defaults to 3.10-alpine3.20. Applicable, if `isolate is True`\n        docker_config: Docker client configuration. Applicable, if `isolate is True`\n\n    Returns:\n        Runtime instance\n    \"\"\"\n    if isolate:\n        if (proc := Path(\"/proc/1/cgroup\")).exists() and \"docker\" in proc.read_text():\n            ExecutionRuntime.logger.info(\"Already inside a container. Switched to host.\")\n            return ExecutionRuntime()\n\n        IsolatedExecutionRuntime.logger.info(\"Setting up the instance\")\n        return IsolatedExecutionRuntime(python_tag=python_tag, **docker_config)\n\n    ExecutionRuntime.logger.info(\"Setting up the instance\")\n    return ExecutionRuntime()\n</code></pre>"},{"location":"api_reference/execution-runtime/#executionruntime-host-based","title":"ExecutionRuntime (host-based)","text":"<p>Interface for running Python scripts and created projects in the host machine.</p> <pre><code># Create a host execution runtime instance\nruntime = ExecutionRuntime()\n\n# Run a script with auto-generated requirements\noutput = runtime.run_script('script1.py', '-p1', 'value1', requirements=True)\n\n# Run a script with pre-defined requirements\noutput = runtime.run_script('script2.py', requirements=[\"requests==2.25.1\"])\n\n# Run a created project\noutput = runtime.run_project('project_id', '--param1', 'value1')\n</code></pre> Source code in <code>orchestr8/execution_runtime/__init__.py</code> <pre><code>class ExecutionRuntime(Logger):\n    \"\"\"\n    Interface for running Python scripts and created projects in the host machine.\n\n    ```python\n    # Create a host execution runtime instance\n    runtime = ExecutionRuntime()\n\n    # Run a script with auto-generated requirements\n    output = runtime.run_script('script1.py', '-p1', 'value1', requirements=True)\n\n    # Run a script with pre-defined requirements\n    output = runtime.run_script('script2.py', requirements=[\"requests==2.25.1\"])\n\n    # Run a created project\n    output = runtime.run_project('project_id', '--param1', 'value1')\n    ```\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the runtime.\"\"\"\n        self.__shell = Shell(workdir=RUNTIME_PROJECTS_DIR)\n        if os.name == \"nt\":\n            self._py_exe_loc = \"Scripts\"  # windows\n        else:\n            self._py_exe_loc = \"bin\"  # unix\n\n    @property\n    def shell(self) -&gt; Shell:\n        \"\"\"The shell instance.\"\"\"\n        return self.__shell\n\n    def run_project(self, __id: str, *args: SupportsStr, env: Dict[str, str] | None = None) -&gt; str | None:\n        \"\"\"\n        Run the project with the given id.\n\n        Args:\n            __id: The id of the project to run\n            args: The arguments to pass to the script associated with the project\n            env: Environment variables required by the project\n\n        Returns:\n            The output of the script\n\n        Raises:\n            FileNotFoundError: If the project with the given id does not exist\n        \"\"\"\n        if not project_exists(__id):\n            raise FileNotFoundError(f\"Project with id {__id!r} not found.\")\n\n        project_dir = RUNTIME_PROJECTS_DIR / __id\n        python_exe = str(project_dir / \".venv\" / self._py_exe_loc / \"python\")\n        main_py = str(project_dir / \"main.py\")\n        return self.__shell.run(python_exe, main_py, *list(map(str, args)), env=env)\n\n    def run_script(\n        self,\n        __script: str | Path | BytesIO,\n        *args: SupportsStr,\n        env: Dict[str, str] | None = None,\n        requirements: List[str] | Literal[True] | None = None,\n        dependency_overrides: Dict[str, Dependency] | None = None,\n    ) -&gt; str | None:\n        \"\"\"\n        Run a python script inside on-demand environment.\n\n        Reference: https://docs.astral.sh/uv/guides/scripts/#running-a-script-with-dependencies\n\n        To know more about auto-generation of requirements from python source\n        file, refer `orchestr8.execution_runtime.package_utils.generate_requirements`.\n\n        Args:\n            __script: The python script to run\n            args: The arguments to pass to the script\n            env: Environment variables required by the script\n            requirements: List of requirement strings (e.g., [\"package==1.0.0\"]) or True to auto-generate\n            dependency_overrides: Depedency overrides. Applicable only if requirements=True\n\n        Returns:\n            The output of the script\n        \"\"\"\n        script, requirements = _validate_script_and_requirements(\n            script=__script, requirements=requirements, dependency_overrides=dependency_overrides\n        )\n\n        self.logger.info(f\"Running script {script.name!r}\")\n        cmd = [\"uv\", \"run\", \"--no-project\", \"--quiet\"]\n        if requirements:\n            cmd.extend([\"--with\", *requirements])\n        cmd.append(str(script.absolute()))\n        if args:\n            cmd.extend(list(map(str, args)))\n        return self.__shell.run(*cmd, env=env)\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.ExecutionRuntime.shell","title":"<code>shell: Shell</code>  <code>property</code>","text":"<p>The shell instance.</p>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.ExecutionRuntime.run_project","title":"<code>run_project</code>","text":"<p>Run the project with the given id.</p> <p>Parameters:</p> Name Type Description Default <code>__id</code> <code>str</code> <p>The id of the project to run</p> required <code>args</code> <code>SupportsStr</code> <p>The arguments to pass to the script associated with the project</p> <code>()</code> <code>env</code> <code>Dict[str, str] | None</code> <p>Environment variables required by the project</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The output of the script</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the project with the given id does not exist</p> Source code in <code>orchestr8/execution_runtime/__init__.py</code> <pre><code>def run_project(self, __id: str, *args: SupportsStr, env: Dict[str, str] | None = None) -&gt; str | None:\n    \"\"\"\n    Run the project with the given id.\n\n    Args:\n        __id: The id of the project to run\n        args: The arguments to pass to the script associated with the project\n        env: Environment variables required by the project\n\n    Returns:\n        The output of the script\n\n    Raises:\n        FileNotFoundError: If the project with the given id does not exist\n    \"\"\"\n    if not project_exists(__id):\n        raise FileNotFoundError(f\"Project with id {__id!r} not found.\")\n\n    project_dir = RUNTIME_PROJECTS_DIR / __id\n    python_exe = str(project_dir / \".venv\" / self._py_exe_loc / \"python\")\n    main_py = str(project_dir / \"main.py\")\n    return self.__shell.run(python_exe, main_py, *list(map(str, args)), env=env)\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.ExecutionRuntime.run_script","title":"<code>run_script</code>","text":"<p>Run a python script inside on-demand environment.</p> <p>Reference: https://docs.astral.sh/uv/guides/scripts/#running-a-script-with-dependencies</p> <p>To know more about auto-generation of requirements from python source file, refer <code>orchestr8.execution_runtime.package_utils.generate_requirements</code>.</p> <p>Parameters:</p> Name Type Description Default <code>__script</code> <code>str | Path | BytesIO</code> <p>The python script to run</p> required <code>args</code> <code>SupportsStr</code> <p>The arguments to pass to the script</p> <code>()</code> <code>env</code> <code>Dict[str, str] | None</code> <p>Environment variables required by the script</p> <code>None</code> <code>requirements</code> <code>List[str] | Literal[True] | None</code> <p>List of requirement strings (e.g., [\"package==1.0.0\"]) or True to auto-generate</p> <code>None</code> <code>dependency_overrides</code> <code>Dict[str, Dependency] | None</code> <p>Depedency overrides. Applicable only if requirements=True</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The output of the script</p> Source code in <code>orchestr8/execution_runtime/__init__.py</code> <pre><code>def run_script(\n    self,\n    __script: str | Path | BytesIO,\n    *args: SupportsStr,\n    env: Dict[str, str] | None = None,\n    requirements: List[str] | Literal[True] | None = None,\n    dependency_overrides: Dict[str, Dependency] | None = None,\n) -&gt; str | None:\n    \"\"\"\n    Run a python script inside on-demand environment.\n\n    Reference: https://docs.astral.sh/uv/guides/scripts/#running-a-script-with-dependencies\n\n    To know more about auto-generation of requirements from python source\n    file, refer `orchestr8.execution_runtime.package_utils.generate_requirements`.\n\n    Args:\n        __script: The python script to run\n        args: The arguments to pass to the script\n        env: Environment variables required by the script\n        requirements: List of requirement strings (e.g., [\"package==1.0.0\"]) or True to auto-generate\n        dependency_overrides: Depedency overrides. Applicable only if requirements=True\n\n    Returns:\n        The output of the script\n    \"\"\"\n    script, requirements = _validate_script_and_requirements(\n        script=__script, requirements=requirements, dependency_overrides=dependency_overrides\n    )\n\n    self.logger.info(f\"Running script {script.name!r}\")\n    cmd = [\"uv\", \"run\", \"--no-project\", \"--quiet\"]\n    if requirements:\n        cmd.extend([\"--with\", *requirements])\n    cmd.append(str(script.absolute()))\n    if args:\n        cmd.extend(list(map(str, args)))\n    return self.__shell.run(*cmd, env=env)\n</code></pre>"},{"location":"api_reference/execution-runtime/#isolatedexecutionruntime","title":"IsolatedExecutionRuntime","text":"<p>Interface for running Python scripts and created projects in isolated environments.</p> <pre><code># Create an isolated execution runtime instance\nruntime = IsolatedExecutionRuntime(isolate=True, python_tag=\"3.10-alpine3.20\")\n\n# Run a script with auto-generated requirements\noutput = runtime.run_script('script1.py', '-p1', 'value1', requirements=True)\n\n# Run a script with pre-defined requirements\noutput = runtime.run_script('script2.py', requirements=[\"requests==2.25.1\"])\n\n# Run a created project\noutput = runtime.run_project('project_id', '--param1', 'value1')\n</code></pre> Source code in <code>orchestr8/execution_runtime/__init__.py</code> <pre><code>class IsolatedExecutionRuntime(Logger):\n    \"\"\"\n    Interface for running Python scripts and created projects in isolated environments.\n\n    ```python\n    # Create an isolated execution runtime instance\n    runtime = IsolatedExecutionRuntime(isolate=True, python_tag=\"3.10-alpine3.20\")\n\n    # Run a script with auto-generated requirements\n    output = runtime.run_script('script1.py', '-p1', 'value1', requirements=True)\n\n    # Run a script with pre-defined requirements\n    output = runtime.run_script('script2.py', requirements=[\"requests==2.25.1\"])\n\n    # Run a created project\n    output = runtime.run_project('project_id', '--param1', 'value1')\n    ```\n    \"\"\"\n\n    def __init__(self, *, python_tag: str | None = None, **docker_config: Any) -&gt; None:\n        \"\"\"\n        Initialize the runtime.\n\n        :param python_tag: Python image tag. Defaults to 3.10-alpine3.20.\n        :type python_tag: str | None\n        :param docker_config: Docker client configuration.\n        :type docker_config: dict[str, Any]\n        \"\"\"\n        minor, major = sys.version_info[:2]\n        python_tag = python_tag or f\"{minor}.{major}-alpine3.20\"\n\n        if not (m := re_match(r\"^(\\d+\\.\\d+)\", python_tag)):\n            raise ValueError(f\"Invalid python tag: {python_tag!r}\")\n\n        python_version: str = m.group(1)\n        self.__venvs_dir = ISOLATED_RUNTIME_VENVS_VOLUME_DIR / python_version\n        if not self.__venvs_dir.is_dir():\n            self.__venvs_dir.mkdir(exist_ok=True)\n\n        py_image = f\"python:{python_tag}\"\n        self.__sb_client = SandboxClient(**docker_config)\n        if not self.__sb_client.image_exists(py_image) and not (\n            self.__sb_client.image_exists(py_image, where=\"registry\")\n        ):\n            raise Exception(f\"Python image {py_image!r} not found on docker hub.\")\n\n        executor_image = f\"orchestr8-runtime:py-{python_tag}\"\n        if not self.__sb_client.image_exists(executor_image):\n            self.__sb_client.build_image(\n                image=executor_image, dockerfile=BytesIO(EXECUTOR_IMAGE_TEMPLATE.format(python_tag=python_tag).encode())\n            )\n\n        # Project directory inside the container, host project directory is mounted\n        projs_dir_mount = \"/var/o8-projects\"\n        container = self.__sb_client.run_container(\n            executor_image,\n            volumes={\n                RUNTIME_PROJECTS_DIR: {\"bind\": projs_dir_mount, \"mode\": \"ro\"},\n                self.__venvs_dir: {\"bind\": \"/var/o8-venvs\", \"mode\": \"rw\"},\n            },\n            detach=True,\n            stderr=True,\n            remove=True,\n        )\n        self.__shell = IsolatedShell(container=container, workdir=projs_dir_mount)\n\n    @property\n    def shell(self) -&gt; IsolatedShell:\n        \"\"\"The shell instance.\"\"\"\n        return self.__shell\n\n    def run_project(self, __id: str, *args: SupportsStr, env: Dict[str, str] | None = None) -&gt; str | None:\n        \"\"\"\n        Run the project with the given id.\n\n        Args:\n            __id: The id of the project to run\n            args: The arguments to pass to the script associated with the project\n            env: Environment variables required by the project\n\n        Returns:\n            The output of the script\n\n        Raises:\n            FileNotFoundError: If the project with the given id does not exist\n        \"\"\"\n        if not project_exists(__id):\n            raise FileNotFoundError(f\"Project with id {__id!r} not found.\")\n\n        venv_dir_mount = Path(\"/var\") / \"o8-venvs\" / __id\n        proj_dir_mount = Path(\"/var\") / \"o8-projects\" / __id\n        if not (self.__venvs_dir / __id).exists():\n            self.logger.info(f\"Creating virtual environment for project {__id!r}\")\n            self.__shell.run(\"uv\", \"venv\", \"--no-project\", venv_dir_mount.as_posix())\n\n            if (RUNTIME_PROJECTS_DIR / __id / \"requirements.txt\").exists():\n                self.logger.info(f\"Installing requirements for project {__id!r}\")\n                self.__shell.run(\n                    \"uv\",\n                    \"pip\",\n                    \"install\",\n                    \"-r\",\n                    (proj_dir_mount / \"requirements.txt\").as_posix(),\n                    env={\"VIRTUAL_ENV\": venv_dir_mount.as_posix()},\n                )\n\n        python_exe = (venv_dir_mount / \"bin\" / \"python\").as_posix()\n        main_py = (proj_dir_mount / \"main.py\").as_posix()\n        return self.__shell.run(python_exe, main_py, *list(map(str, args)), env=env)\n\n    def run_script(\n        self,\n        __script: str | Path | BytesIO,\n        *args: SupportsStr,\n        env: Dict[str, str] | None = None,\n        requirements: List[str] | Literal[True] | None = None,\n        dependency_overrides: Dict[str, Dependency] | None = None,\n    ) -&gt; str | None:\n        \"\"\"\n        Run a python script inside on-demand environment.\n\n        Reference: https://docs.astral.sh/uv/guides/scripts/#running-a-script-with-dependencies\n\n        To know more about auto-generation of requirements from python source\n        file, refer `orchestr8.execution_runtime.package_utils.generate_requirements`.\n\n        Args:\n            __script: The python script to run.\n            args: The arguments to pass to the script\n            env: Environment variables required by the script\n            requirements: List of requirement strings (e.g., [\"package==1.0.0\"]) or True to auto-generate\n            dependency_overrides: Depedency overrides. Applicable only if requirements=True\n\n        Returns:\n            The output of the script\n        \"\"\"\n        script, requirements = _validate_script_and_requirements(\n            script=__script, requirements=requirements, dependency_overrides=dependency_overrides\n        )\n        self.__sb_client.copy_path_to_container(self.__shell.container.id, src=script, target=\"/tmp\")  # noqa: S108\n\n        self.logger.info(f\"Running script {script.name!r}\")\n        cmd = [\"uv\", \"run\", \"--no-project\", \"--quiet\"]\n        if requirements:\n            cmd.extend([\"--with\", *requirements])\n        cmd.append(f\"/tmp/{script.name}\")  # noqa: S108\n        if args:\n            cmd.extend(list(map(str, args)))\n        return self.__shell.run(*cmd, env=env)\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.IsolatedExecutionRuntime.shell","title":"<code>shell: IsolatedShell</code>  <code>property</code>","text":"<p>The shell instance.</p>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.IsolatedExecutionRuntime.run_project","title":"<code>run_project</code>","text":"<p>Run the project with the given id.</p> <p>Parameters:</p> Name Type Description Default <code>__id</code> <code>str</code> <p>The id of the project to run</p> required <code>args</code> <code>SupportsStr</code> <p>The arguments to pass to the script associated with the project</p> <code>()</code> <code>env</code> <code>Dict[str, str] | None</code> <p>Environment variables required by the project</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The output of the script</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the project with the given id does not exist</p> Source code in <code>orchestr8/execution_runtime/__init__.py</code> <pre><code>def run_project(self, __id: str, *args: SupportsStr, env: Dict[str, str] | None = None) -&gt; str | None:\n    \"\"\"\n    Run the project with the given id.\n\n    Args:\n        __id: The id of the project to run\n        args: The arguments to pass to the script associated with the project\n        env: Environment variables required by the project\n\n    Returns:\n        The output of the script\n\n    Raises:\n        FileNotFoundError: If the project with the given id does not exist\n    \"\"\"\n    if not project_exists(__id):\n        raise FileNotFoundError(f\"Project with id {__id!r} not found.\")\n\n    venv_dir_mount = Path(\"/var\") / \"o8-venvs\" / __id\n    proj_dir_mount = Path(\"/var\") / \"o8-projects\" / __id\n    if not (self.__venvs_dir / __id).exists():\n        self.logger.info(f\"Creating virtual environment for project {__id!r}\")\n        self.__shell.run(\"uv\", \"venv\", \"--no-project\", venv_dir_mount.as_posix())\n\n        if (RUNTIME_PROJECTS_DIR / __id / \"requirements.txt\").exists():\n            self.logger.info(f\"Installing requirements for project {__id!r}\")\n            self.__shell.run(\n                \"uv\",\n                \"pip\",\n                \"install\",\n                \"-r\",\n                (proj_dir_mount / \"requirements.txt\").as_posix(),\n                env={\"VIRTUAL_ENV\": venv_dir_mount.as_posix()},\n            )\n\n    python_exe = (venv_dir_mount / \"bin\" / \"python\").as_posix()\n    main_py = (proj_dir_mount / \"main.py\").as_posix()\n    return self.__shell.run(python_exe, main_py, *list(map(str, args)), env=env)\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.IsolatedExecutionRuntime.run_script","title":"<code>run_script</code>","text":"<p>Run a python script inside on-demand environment.</p> <p>Reference: https://docs.astral.sh/uv/guides/scripts/#running-a-script-with-dependencies</p> <p>To know more about auto-generation of requirements from python source file, refer <code>orchestr8.execution_runtime.package_utils.generate_requirements</code>.</p> <p>Parameters:</p> Name Type Description Default <code>__script</code> <code>str | Path | BytesIO</code> <p>The python script to run.</p> required <code>args</code> <code>SupportsStr</code> <p>The arguments to pass to the script</p> <code>()</code> <code>env</code> <code>Dict[str, str] | None</code> <p>Environment variables required by the script</p> <code>None</code> <code>requirements</code> <code>List[str] | Literal[True] | None</code> <p>List of requirement strings (e.g., [\"package==1.0.0\"]) or True to auto-generate</p> <code>None</code> <code>dependency_overrides</code> <code>Dict[str, Dependency] | None</code> <p>Depedency overrides. Applicable only if requirements=True</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The output of the script</p> Source code in <code>orchestr8/execution_runtime/__init__.py</code> <pre><code>def run_script(\n    self,\n    __script: str | Path | BytesIO,\n    *args: SupportsStr,\n    env: Dict[str, str] | None = None,\n    requirements: List[str] | Literal[True] | None = None,\n    dependency_overrides: Dict[str, Dependency] | None = None,\n) -&gt; str | None:\n    \"\"\"\n    Run a python script inside on-demand environment.\n\n    Reference: https://docs.astral.sh/uv/guides/scripts/#running-a-script-with-dependencies\n\n    To know more about auto-generation of requirements from python source\n    file, refer `orchestr8.execution_runtime.package_utils.generate_requirements`.\n\n    Args:\n        __script: The python script to run.\n        args: The arguments to pass to the script\n        env: Environment variables required by the script\n        requirements: List of requirement strings (e.g., [\"package==1.0.0\"]) or True to auto-generate\n        dependency_overrides: Depedency overrides. Applicable only if requirements=True\n\n    Returns:\n        The output of the script\n    \"\"\"\n    script, requirements = _validate_script_and_requirements(\n        script=__script, requirements=requirements, dependency_overrides=dependency_overrides\n    )\n    self.__sb_client.copy_path_to_container(self.__shell.container.id, src=script, target=\"/tmp\")  # noqa: S108\n\n    self.logger.info(f\"Running script {script.name!r}\")\n    cmd = [\"uv\", \"run\", \"--no-project\", \"--quiet\"]\n    if requirements:\n        cmd.extend([\"--with\", *requirements])\n    cmd.append(f\"/tmp/{script.name}\")  # noqa: S108\n    if args:\n        cmd.extend(list(map(str, args)))\n    return self.__shell.run(*cmd, env=env)\n</code></pre>"},{"location":"api_reference/execution-runtime/#package_utils","title":"package_utils","text":""},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.package_utils.Dependency","title":"<code>Dependency</code>","text":"<p>Dependency specification with package name and version requirements.</p> Source code in <code>orchestr8/execution_runtime/package_utils.py</code> <pre><code>class Dependency(TypedDict):\n    \"\"\"Dependency specification with package name and version requirements.\"\"\"\n\n    package_name: NotRequired[str]\n    specifiers: NotRequired[List[Specifier]]\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.package_utils.ReleaseInfo","title":"<code>ReleaseInfo</code>","text":"<p>Release information</p> Source code in <code>orchestr8/execution_runtime/package_utils.py</code> <pre><code>class ReleaseInfo(TypedDict):\n    \"\"\"Release information\"\"\"\n\n    ids: List[str]\n    latest: str\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.package_utils.Specifier","title":"<code>Specifier</code>","text":"<p>Version specifier.</p> <p>Represents a package version specifier with an operator and version string.</p> Source code in <code>orchestr8/execution_runtime/package_utils.py</code> <pre><code>class Specifier(TypedDict):\n    \"\"\"\n    Version specifier.\n\n    Represents a package version specifier with an operator and version string.\n    \"\"\"\n\n    version: str\n    op: Literal[\"==\", \"&gt;=\", \"&lt;=\", \"&gt;\", \"&lt;\", \"~=\", \"===\", \"!=\"]\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.package_utils.extract_module_names","title":"<code>extract_module_names</code>","text":"<p>Extract imported module names from a Python script or AST Module.</p> <p>Analyzes Python source code to find all imported module names, including those within conditional statements (if/else) and try/except blocks. For 'import' statements, only the root module name is extracted (e.g., 'pandas' from 'pandas.DataFrame'). For 'from' imports, the module being imported from is extracted.</p> <p>```python script = Path('example.py')  # Contains: import pandas as pd; from numpy import array extract_module_names(script)</p>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.package_utils.extract_module_names--output-pandas-numpy","title":"output: ['pandas', 'numpy']","text":"<p>Args:     script: Either a Path to a Python file or an ast.Module object</p> <p>Returns:     List of unique module names found in the script</p> <p>Raises:     FileNotFoundError: If the script path does not exist</p> Source code in <code>orchestr8/execution_runtime/package_utils.py</code> <pre><code>def extract_module_names(script: Path | ast.Module) -&gt; List[str]:  # noqa: C901\n    \"\"\"\n    Extract imported module names from a Python script or AST Module.\n\n    Analyzes Python source code to find all imported module names, including those within\n    conditional statements (if/else) and try/except blocks. For 'import' statements,\n    only the root module name is extracted (e.g., 'pandas' from 'pandas.DataFrame').\n    For 'from' imports, the module being imported from is extracted.\n\n\n    ```python\n    script = Path('example.py')  # Contains: import pandas as pd; from numpy import array\n    extract_module_names(script)\n    # output: ['pandas', 'numpy']\n\n    Args:\n        script: Either a Path to a Python file or an ast.Module object\n\n    Returns:\n        List of unique module names found in the script\n\n    Raises:\n        FileNotFoundError: If the script path does not exist\n    \"\"\"\n\n    class ModuleExtractor(ast.NodeVisitor):\n        def __init__(self) -&gt; None:\n            self.module_names: Set[str] = set()\n\n        def visit_Import(self, node: ast.Import) -&gt; None:\n            for alias in node.names:\n                self.module_names.add(alias.name.split(\".\")[0])\n\n        def visit_ImportFrom(self, node: ast.ImportFrom) -&gt; None:\n            if node.level == 0 and node.module:\n                self.module_names.add(node.module)\n\n        def visit_If(self, node: ast.If) -&gt; None:\n            self.visit(node.test)\n\n            for stmt in node.body:\n                self.visit(stmt)\n\n            if node.orelse:\n                for stmt in node.orelse:\n                    self.visit(stmt)\n\n        def visit_Try(self, node: ast.Try) -&gt; None:\n            for stmt in node.body:\n                self.visit(stmt)\n\n            for handler in node.handlers:\n                for stmt in handler.body:\n                    self.visit(stmt)\n\n            if node.orelse:\n                for stmt in node.orelse:\n                    self.visit(stmt)\n\n            if node.finalbody:\n                for stmt in node.finalbody:\n                    self.visit(stmt)\n\n    if isinstance(script, Path):\n        if not script.is_file():\n            raise FileNotFoundError(f\"Script {script!r} not found.\")\n        script = ast.parse(script.read_bytes())\n\n    extractor = ModuleExtractor()\n    extractor.visit(script)\n    return list(extractor.module_names)\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.package_utils.generate_requirements","title":"<code>generate_requirements</code>","text":"<p>Generate a list of Python package requirements from module names.</p> <p>For extracting module names from a Python script, use:</p> <pre><code>from orchestr8.runtime.utils import extract_module_names\nmodule_names = extract_module_names(\"/path/to/script.py\")\n</code></pre> <p>The function follows a systematic approach to resolving package dependencies:</p> <p>First, standard library modules are automatically excluded from the processing. The remaining modules are then searched among globally installed packages. When a module is found in installed packages, its package name and version are used.</p> <p>If a module is not installed locally, the function searches the PyPI package index. When a package is found on PyPI, its latest version is utilized. If no package can be found, the function raises an error.</p> <p>The function provides flexibility through the <code>dependency_overrides</code> parameter. This is particularly useful in scenarios where: - The package name differs from the module name - Custom version specifications are required</p> <p>A prime example is the <code>yaml</code> module, which corresponds to the <code>PyYAML</code> package. Through dependency overrides, you can specify custom package names or version constraints.</p> <p>The function performs comprehensive validation: - Checks if specified versions exist in package releases - Validates version specifiers against available package versions - Ensures precise and correct dependency specification</p> <pre><code>generate_requirements(['pandas', 'numpy'])\n# output: ['pandas==2.0.0', 'numpy==1.24.0']\n\noverrides = {\n    'yaml': {\n        'package_name': 'PyYAML',\n        'specifiers': [{'version': '6.0', 'op': '=='}]\n    }\n}\ngenerate_requirements(['yaml'], overrides)\n# output: ['PyYAML==6.0']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>module_names</code> <code>List[str]</code> <p>List of Python module names to process</p> required <code>dependency_overrides</code> <code>Dict[str, Dependency] | None</code> <p>Dependency overrides for specific modules</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of requirement strings (e.g., [\"package==1.0.0\"])</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If specified package name or versions in overrides are invalid or not found</p> <code>LookupError</code> <p>If a package cannot be located on PyPI</p> <code>ConnectionError</code> <p>If network-related issues occur when fetching package information</p> Source code in <code>orchestr8/execution_runtime/package_utils.py</code> <pre><code>def generate_requirements(\n    module_names: List[str], dependency_overrides: Dict[str, Dependency] | None = None\n) -&gt; List[str]:\n    \"\"\"\n    Generate a list of Python package requirements from module names.\n\n    For extracting module names from a Python script, use:\n\n    ```python\n    from orchestr8.runtime.utils import extract_module_names\n    module_names = extract_module_names(\"/path/to/script.py\")\n    ```\n\n    The function follows a systematic approach to resolving package dependencies:\n\n    First, standard library modules are automatically excluded from the processing.\n    The remaining modules are then searched among globally installed packages.\n    When a module is found in installed packages, its package name and version are used.\n\n    If a module is not installed locally, the function searches the PyPI package index.\n    When a package is found on PyPI, its latest version is utilized.\n    If no package can be found, the function raises an error.\n\n    The function provides flexibility through the `dependency_overrides` parameter.\n    This is particularly useful in scenarios where:\n    - The package name differs from the module name\n    - Custom version specifications are required\n\n    A prime example is the `yaml` module, which corresponds to the `PyYAML` package.\n    Through dependency overrides, you can specify custom package names or version constraints.\n\n    The function performs comprehensive validation:\n    - Checks if specified versions exist in package releases\n    - Validates version specifiers against available package versions\n    - Ensures precise and correct dependency specification\n\n    ```python\n    generate_requirements(['pandas', 'numpy'])\n    # output: ['pandas==2.0.0', 'numpy==1.24.0']\n\n    overrides = {\n        'yaml': {\n            'package_name': 'PyYAML',\n            'specifiers': [{'version': '6.0', 'op': '=='}]\n        }\n    }\n    generate_requirements(['yaml'], overrides)\n    # output: ['PyYAML==6.0']\n    ```\n\n    Args:\n        module_names: List of Python module names to process\n        dependency_overrides: Dependency overrides for specific modules\n\n    Returns:\n        List of requirement strings (e.g., [\"package==1.0.0\"])\n\n    Raises:\n        ValueError: If specified package name or versions in overrides are invalid or not found\n        LookupError: If a package cannot be located on PyPI\n        ConnectionError: If network-related issues occur when fetching package information\n    \"\"\"\n    requirements = []\n    installables = set(module_names) - get_stdlib_modules()\n    for mod_name, dep in (dependency_overrides or {}).items():\n        if mod_name in installables:\n            installables.remove(mod_name)\n        pkg_name = dep.get(\"package_name\") or mod_name\n        release_info = get_package_release_info(pkg_name)\n        if specifiers := dep.get(\"specifiers\"):\n            spec_versions = {spec[\"version\"] for spec in specifiers}\n            specifier_set = SpecifierSet(\",\".join(f\"{spec['op']}{spec['version']}\" for spec in specifiers))\n            available_versions = release_info[\"ids\"]\n            not_found = list(spec_versions.difference(available_versions))\n            if not_found:\n                raise ValueError(f\"Versions {not_found!r} mentioned in specifiers not found in {pkg_name!r} releases.\")\n\n            if not any(Version(v) in specifier_set for v in available_versions):\n                raise ValueError(\n                    f\"Specifiers specified for package {pkg_name!r} are invalid. \"\n                    f\"Avaiable versions: {available_versions!r}\"\n                )\n            requirements.append(f\"{pkg_name}{specifier_set!s}\")\n        else:\n            requirements.append(f\"{pkg_name}=={release_info['latest']}\")\n\n    mod_mapped_pkgs = get_module_mapped_packages()\n    for mod_name in installables:\n        if local_pkgs := mod_mapped_pkgs.get(mod_name):\n            # Some modules have more than one package, so we'll include all available ones.\n            for pkg_name, version in local_pkgs.items():\n                release_info = get_package_release_info(pkg_name)\n                if version in release_info[\"ids\"]:\n                    requirements.append(f\"{pkg_name}=={version}\")\n        else:\n            # We use the module name as the package name\n            release_info = get_package_release_info(mod_name)\n            requirements.append(f\"{mod_name}=={release_info['latest']}\")\n\n    return requirements\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.package_utils.get_module_mapped_packages","title":"<code>get_module_mapped_packages</code>","text":"<p>Map Python module names to their corresponding package information.</p> <p>Creates a mapping of module names to dictionaries containing package names and their versions based on installed distributions.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, str]]</code> <p>Dictionary mapping module names to {package_name: version} dictionaries</p> Source code in <code>orchestr8/execution_runtime/package_utils.py</code> <pre><code>def get_module_mapped_packages() -&gt; Dict[str, Dict[str, str]]:\n    \"\"\"\n    Map Python module names to their corresponding package information.\n\n    Creates a mapping of module names to dictionaries containing package names\n    and their versions based on installed distributions.\n\n    Returns:\n        Dictionary mapping module names to {package_name: version} dictionaries\n    \"\"\"\n    module_to_packages = defaultdict(dict[str, str])  # type: ignore[var-annotated]\n    for dist in distributions():\n        try:\n            if not (\n                pkg_name := getattr(\n                    dist,\n                    \"name\",\n                    dist.metadata.get(\"Name\", \"\"),  # type: ignore[attr-defined]\n                )\n            ):\n                continue\n\n            top_level_text = dist.read_text(\"top_level.txt\")\n            if top_level_text:\n                for mod_name in top_level_text.split():\n                    module_to_packages[mod_name][pkg_name] = (\n                        getattr(dist, \"version\", None) or dist.metadata.get(\"Version\", \"\") or \"\"  # type: ignore[attr-defined]\n                    )\n        except Exception:  # noqa: S112\n            # Silently skip distributions that cause issues\n            continue\n\n    return dict(module_to_packages)\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.package_utils.get_package_release_info","title":"<code>get_package_release_info</code>","text":"<p>Fetch package release information from PyPI or custom package index.</p> <p>Parameters:</p> Name Type Description Default <code>__name</code> <code>str</code> <p>Name of the package to look up</p> required <code>resolver_url</code> <code>str | None</code> <p>Custom package index URL. Defaults to PyPI</p> <code>None</code> <code>urllib_request_kwargs</code> <code>Any</code> <p>Additional keyword arguments for urllib.request.Request</p> <code>{}</code> <p>Returns:</p> Type Description <code>ReleaseInfo</code> <p>Dictionary containing 'ids' (list of versions) and 'latest' (latest version)</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>If the package is not found</p> <code>ConnectionError</code> <p>If there are network issues or invalid responses</p> Source code in <code>orchestr8/execution_runtime/package_utils.py</code> <pre><code>def get_package_release_info(__name: str, resolver_url: str | None = None, **urllib_request_kwargs: Any) -&gt; ReleaseInfo:\n    \"\"\"\n    Fetch package release information from PyPI or custom package index.\n\n    Args:\n        __name: Name of the package to look up\n        resolver_url: Custom package index URL. Defaults to PyPI\n        urllib_request_kwargs: Additional keyword arguments for urllib.request.Request\n\n    Returns:\n        Dictionary containing 'ids' (list of versions) and 'latest' (latest version)\n\n    Raises:\n        LookupError: If the package is not found\n        ConnectionError: If there are network issues or invalid responses\n    \"\"\"\n    from urllib.error import HTTPError, URLError\n    from urllib.request import Request, urlopen\n\n    base_url = (resolver_url or \"https://pypi.python.org/pypi/\").rstrip(\"/\")\n    url = f\"{base_url}/{__name}/json\"\n    try:\n        with urlopen(Request(url, **urllib_request_kwargs)) as response:  # noqa: S310\n            if response.status != 200:\n                raise ConnectionError(\n                    f\"An error occurred requesting {base_url!r} for package {__name!r}. \"\n                    f\"Status code: {response.status}\"\n                )\n\n            response_data = response.read().decode(\"utf-8\")\n            json_data: Dict[str, dict] = json.loads(response_data)\n\n            return {\n                \"ids\": list(json_data.get(\"releases\", {}).keys()),\n                \"latest\": json_data.get(\"info\", {}).get(\"version\"),  # type: ignore[typeddict-item]\n            }\n\n    except HTTPError as e:\n        if e.code == 404:\n            raise LookupError(f\"Package {__name!r} not found.\") from e\n        raise ConnectionError(\n            f\"An error occurred requesting {base_url!r} for package {__name!r}. \"\n            f\"Status code: {e.code}, Response: {e.read().decode('utf-8')}\"\n        ) from e\n\n    except URLError as e:\n        raise ConnectionError(f\"Failed to connect to {base_url!r} for package {__name!r}. \" f\"Error: {e!s}\") from e\n</code></pre>"},{"location":"api_reference/execution-runtime/#orchestr8.execution_runtime.package_utils.get_stdlib_modules","title":"<code>get_stdlib_modules</code>","text":"<p>Get a set of all Python standard library module names.</p> <p>Returns:</p> Type Description <code>FrozenSet[str]</code> <p>Set of standard library module names read from stdlib.txt</p> Source code in <code>orchestr8/execution_runtime/package_utils.py</code> <pre><code>def get_stdlib_modules() -&gt; FrozenSet[str]:\n    \"\"\"\n    Get a set of all Python standard library module names.\n\n    Returns:\n        Set of standard library module names read from stdlib.txt\n    \"\"\"\n    return frozenset(line.strip() for line in (Path(__file__).parent / \"stdlib.txt\").open().readlines())\n</code></pre>"},{"location":"api_reference/logger/","title":"orchestr8.logger","text":"<p>Logger class that can be inherited for class based logging.</p> <pre><code>class ClassName(Logger, format=\"&lt;level&gt;{message}&lt;/level&gt;\"):\n    def __init__(self):\n        self.logger.info(\"Class initialized\")\n\n    @classmethod\n    def cls_method(cls):\n        cls.logger.info(\"Class method called\")\n\nClassName()\nClassName.cls_method()\nClassName.logger.info(\"Hello Logger\")\n</code></pre> Source code in <code>orchestr8/logger.py</code> <pre><code>class Logger:\n    \"\"\"\n    Logger class that can be inherited for class based logging.\n\n    ```python\n    class ClassName(Logger, format=\"&lt;level&gt;{message}&lt;/level&gt;\"):\n        def __init__(self):\n            self.logger.info(\"Class initialized\")\n\n        @classmethod\n        def cls_method(cls):\n            cls.logger.info(\"Class method called\")\n\n    ClassName()\n    ClassName.cls_method()\n    ClassName.logger.info(\"Hello Logger\")\n    ```\n    \"\"\"\n\n    logger: LoguruLogger\n\n    @classmethod\n    def __init_subclass__(cls, *, format: str | None = None):  # noqa: A002\n        \"\"\"\n        Args:\n            format: Logging format to use.\n        \"\"\"\n        logger.add(\n            sys.stdout,\n            format=format or DEFAULT_LOGGER_FORMAT,\n            filter=lambda record: record[\"extra\"].get(\"class_name\") == cls.__name__,\n        )\n        cls.logger = logger.bind(class_name=cls.__name__).opt(colors=True)  # type: ignore[assignment]\n</code></pre>"},{"location":"api_reference/oauth-flow/","title":"orchestr8.oauth_flow","text":"<p>Base class for OAuth flow implementation.</p> <pre><code>class MyOAuthFlow(OAuthFlow):\n\n    @property\n    def auth_url(self) -&gt; str:\n        return (\n            f\"https://service.com/api/oauth2/authorize\"\n            f\"?client_id={self.client_id}&amp;redirect_uri={self.quoted_redirect_url}\"\n            f\"&amp;response_type=code&amp;scope={self.user_scopes}\"\n        )\n\n    def _generate_access_token(self, code: str) -&gt; str:\n        response = requests.post(\n            \"https://service.com/api/oauth2/token\",\n            data={\n                'grant_type': 'authorization_code',\n                'code': code,\n                'redirect_uri': self.redirect_url,\n            },\n            auth=(self.client_id, self.client_secret)\n        )\n\n        if response.status_code != 200:\n            raise Exception(f\"Failed to obtain access token: {response.json()}\")\n\n        return response.json()['access_token']\n\nmy_oauth_flow = MyOAuthFlow(\n    client_id=\"&lt;client-id&gt;\",\n    client_secret=\"&lt;client-secret&gt;\",\n    user_scopes=\"identify messages.read\",\n)\nmy_oauth_flow.authorize(timeout=30)\n</code></pre> Source code in <code>orchestr8/oauth_flow/__init__.py</code> <pre><code>class OAuthFlow(Logger):\n    \"\"\"Base class for OAuth flow implementation.\n\n    ```python\n    class MyOAuthFlow(OAuthFlow):\n\n        @property\n        def auth_url(self) -&gt; str:\n            return (\n                f\"https://service.com/api/oauth2/authorize\"\n                f\"?client_id={self.client_id}&amp;redirect_uri={self.quoted_redirect_url}\"\n                f\"&amp;response_type=code&amp;scope={self.user_scopes}\"\n            )\n\n        def _generate_access_token(self, code: str) -&gt; str:\n            response = requests.post(\n                \"https://service.com/api/oauth2/token\",\n                data={\n                    'grant_type': 'authorization_code',\n                    'code': code,\n                    'redirect_uri': self.redirect_url,\n                },\n                auth=(self.client_id, self.client_secret)\n            )\n\n            if response.status_code != 200:\n                raise Exception(f\"Failed to obtain access token: {response.json()}\")\n\n            return response.json()['access_token']\n\n    my_oauth_flow = MyOAuthFlow(\n        client_id=\"&lt;client-id&gt;\",\n        client_secret=\"&lt;client-secret&gt;\",\n        user_scopes=\"identify messages.read\",\n    )\n    my_oauth_flow.authorize(timeout=30)\n    ```\n    \"\"\"\n\n    def __init_subclass__(cls, **kwargs: Any) -&gt; None:\n        super().__init_subclass__(**kwargs)\n        cdict = cls.__dict__\n        if not (attr := cdict.get(\"auth_url\", None)) or not isinstance(attr, property):\n            raise TypeError(f\"{cls.__name__} must define 'auth_url' property.\")\n\n        if not (attr := cdict.get(\"_generate_access_token\", None)) or not callable(attr):\n            raise TypeError(f\"{cls.__name__} must define '_generate_access_token' method.\")\n\n    def __new__(cls, *args: Any, **kwargs: Any) -&gt; OAuthFlow:\n        if cls is OAuthFlow:\n            raise TypeError(\"OAuthFlow cannot be instantiated directly\")\n        return super().__new__(cls)\n\n    def __init__(\n        self,\n        *,\n        client_id: str,\n        client_secret: str,\n        user_scopes: str | None = None,\n        redirect_port: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            client_id: Client ID\n            client_secret: Client secret\n            user_scopes: User scopes\n            redirect_port: Port to redirect on. Default: `41539`\n            kwargs: Additional keyword arguments\n        \"\"\"\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.user_scopes = quote_plus(user_scopes or \"\")\n        self.kwargs = kwargs\n\n        self._redirect_server = RedirectServer(port=redirect_port)\n\n    @property\n    def redirect_url(self) -&gt; str:\n        \"\"\"URL of locally hosted server.\"\"\"\n        if not self._redirect_server.is_running:\n            self._redirect_server.start()\n        return self._redirect_server.url\n\n    @property\n    def quoted_redirect_url(self) -&gt; str:\n        \"\"\"Quoted redirect url\"\"\"\n        return quote_plus(self.redirect_url)\n\n    @property\n    def auth_url(self) -&gt; str:\n        \"\"\"Formatted authorization URL for getting code.\"\"\"\n        raise NotImplementedError(\"Property should be implemented by inherited class.\")\n\n    def _get_auth_code(self, *, timeout: int | None = None) -&gt; str:\n        \"\"\"\n        Get authorization code. If timeout is None, it blocks until a request is intercepted.\n\n        Args:\n            timeout: seconds to wait for. Default: `None`\n\n        Returns:\n            Authorization code\n        \"\"\"\n\n        self.logger.info(\n            \"&lt;w&gt;Add this URL to your application's redirect settings:&lt;/w&gt; &lt;u&gt;&lt;le&gt;{}&lt;/le&gt;&lt;/u&gt;\", self.redirect_url\n        )\n        self.logger.info(\"&lt;w&gt;Click this URL to authorize:&lt;/w&gt; &lt;u&gt;&lt;le&gt;{}&lt;/le&gt;&lt;/u&gt;\", self.auth_url)\n\n        if not (req_url := self._redirect_server.intercept(timeout=timeout)):\n            raise TimeoutError(\n                \"No authorization request was intercepted. \" \"The request may have timed out or was never received.\"\n            )\n\n        if codes := parse_qs(urlparse(req_url).query).get(\"code\"):\n            return codes[0]\n\n        raise ConnectionAbortedError(\"Authorization failed or was denied. Please try again.\")\n\n    def _generate_access_token(self, code: str) -&gt; str:\n        \"\"\"\n        Generate access token\n\n        Args:\n            code: Authorization code\n\n        Returns:\n            Access token\n        \"\"\"\n        raise NotImplementedError(\"Method should be implemented by inherited class.\")\n\n    def authorize(self, *, timeout: int | None = None) -&gt; str:\n        \"\"\"\n        Authorize and return access token.\n\n        Args:\n            timeout: seconds to wait for. Default: `None`\n\n        Returns:\n            Access token\n        \"\"\"\n        self.logger.info(\"Starting authorization process\")\n        code = self._get_auth_code(timeout=timeout)\n        self.logger.success(\"Authorization code received\")\n        token = self._generate_access_token(code)\n        self.logger.success(\"Access token generated successfully\")\n        return token\n\n    def __del__(self) -&gt; None:\n        if self._redirect_server.is_running:\n            self._redirect_server.stop()\n</code></pre>"},{"location":"api_reference/oauth-flow/#orchestr8.oauth_flow.OAuthFlow.auth_url","title":"<code>auth_url: str</code>  <code>property</code>","text":"<p>Formatted authorization URL for getting code.</p>"},{"location":"api_reference/oauth-flow/#orchestr8.oauth_flow.OAuthFlow.quoted_redirect_url","title":"<code>quoted_redirect_url: str</code>  <code>property</code>","text":"<p>Quoted redirect url</p>"},{"location":"api_reference/oauth-flow/#orchestr8.oauth_flow.OAuthFlow.redirect_url","title":"<code>redirect_url: str</code>  <code>property</code>","text":"<p>URL of locally hosted server.</p>"},{"location":"api_reference/oauth-flow/#orchestr8.oauth_flow.OAuthFlow.authorize","title":"<code>authorize</code>","text":"<p>Authorize and return access token.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>seconds to wait for. Default: <code>None</code></p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Access token</p> Source code in <code>orchestr8/oauth_flow/__init__.py</code> <pre><code>def authorize(self, *, timeout: int | None = None) -&gt; str:\n    \"\"\"\n    Authorize and return access token.\n\n    Args:\n        timeout: seconds to wait for. Default: `None`\n\n    Returns:\n        Access token\n    \"\"\"\n    self.logger.info(\"Starting authorization process\")\n    code = self._get_auth_code(timeout=timeout)\n    self.logger.success(\"Authorization code received\")\n    token = self._generate_access_token(code)\n    self.logger.success(\"Access token generated successfully\")\n    return token\n</code></pre>"},{"location":"api_reference/oauth-flow/#redirectserver","title":"RedirectServer","text":"<p>Host a redirect server locally.</p> <pre><code>with RedirectServer(port=8080) as server:\n    print(server.url) # https://localhost:8080/\n    print(server.is_running) # True\n    print(server.intercept(timeout=10)) # https://localhost:8080/?code=123456\n</code></pre> Source code in <code>orchestr8/oauth_flow/redirect_server.py</code> <pre><code>class RedirectServer(Logger):\n    \"\"\"\n    Host a redirect server locally.\n\n    ```python\n    with RedirectServer(port=8080) as server:\n        print(server.url) # https://localhost:8080/\n        print(server.is_running) # True\n        print(server.intercept(timeout=10)) # https://localhost:8080/?code=123456\n    ```\n    \"\"\"\n\n    def __init__(\n        self, *, port: int | None = None, success_message: str | None = None, error_message: str | None = None\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            port: Port to host on. Default: `41539`\n            success_message: Message to display when successfully authorized.\n            error_message: Message to display when request is denied or failed.\n        \"\"\"\n        self.__instance: WSGIServer = None  # type: ignore[assignment]\n        self.__host = \"localhost\"\n        self.__port = port or 41539\n        self.__app = RedirectWSGIApp(\n            success_message=success_message or AUTH_SUCCESS_MESSAGE, error_message=error_message or AUTH_ERROR_MESSAGE\n        )\n\n    def __enter__(self) -&gt; RedirectServer:\n        self.start()\n        return self\n\n    def start(self) -&gt; None:\n        \"\"\"Start the server.\"\"\"\n        if self.is_running:\n            return\n\n        if not MKCERT_LOCALHOST_SSL_CERT_FILE.is_file() or not MKCERT_LOCALHOST_SSL_PKEY_FILE.is_file():\n            raise FileNotFoundError(\n                \"Certificate or Private key file not found.\\n\\n\"\n                \"Run the following commands to generate it:\\n\"\n                \"mkcert -install # Skip if already done.\\n\"\n                f'mkcert -cert-file \"{MKCERT_LOCALHOST_SSL_CERT_FILE!s}\" '\n                f'-key-file \"{MKCERT_LOCALHOST_SSL_PKEY_FILE!s}\" localhost'\n            )\n\n        WSGIServer.allow_reuse_address = False\n        server_instance = make_server(\n            self.__host,\n            self.__port,\n            self.__app,  # type: ignore[arg-type]\n            handler_class=_WSGIRequestHandler,\n        )\n\n        sslctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        sslctx.check_hostname = False\n        sslctx.load_cert_chain(certfile=MKCERT_LOCALHOST_SSL_CERT_FILE, keyfile=MKCERT_LOCALHOST_SSL_PKEY_FILE)\n        server_instance.socket = sslctx.wrap_socket(sock=server_instance.socket, server_side=True)\n        self.__instance = server_instance\n        self.logger.info(f\"Redirect server started on &lt;u&gt;{self.__host}:{self.__port}&lt;/u&gt;\")\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Check if server is running.\"\"\"\n        return bool(self.__instance)\n\n    def raise_if_not_running(self) -&gt; None:\n        \"\"\"Raise if server is not running.\"\"\"\n        if not self.is_running:\n            raise RuntimeError(\"Server not running. use `.start()` method.\")\n\n    @property\n    def url(self) -&gt; str:\n        \"\"\"URL of locally hosted server.\"\"\"\n        self.raise_if_not_running()\n        return f\"https://{self.__host}:{self.__port}/\"\n\n    def intercept(self, *, timeout: int | None = None) -&gt; str | None:\n        \"\"\"\n        Intercept incoming request and return its URL.\n        If `timeout` is None, server waits until a request is intercepted.\n\n        Args:\n            timeout: Seconds to wait for. Default: `None`\n\n        Returns:\n            Intercepted request URL if any, else None\n        \"\"\"\n        self.raise_if_not_running()\n        time_out_fmt = f\"{timeout}s\" if timeout is not None else \"nil\"\n        self.logger.info(f\"Intercepting request (timeout: &lt;u&gt;{time_out_fmt}&lt;/u&gt;)\")\n\n        self.__instance.timeout = timeout\n        self.__instance.handle_request()\n        return self.__app.last_request_url\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the server.\"\"\"\n        if self.is_running:\n            self.logger.info(\"Shutting down the server...\")\n            self.__instance.server_close()\n            self.__instance = None  # type: ignore[assignment]\n\n    def __del__(self) -&gt; None:\n        self.stop()\n\n    def __exit__(self, exc_type: Any, exc_value: Any, tb: Any) -&gt; None:\n        self.stop()\n</code></pre>"},{"location":"api_reference/oauth-flow/#orchestr8.oauth_flow.RedirectServer.is_running","title":"<code>is_running: bool</code>  <code>property</code>","text":"<p>Check if server is running.</p>"},{"location":"api_reference/oauth-flow/#orchestr8.oauth_flow.RedirectServer.url","title":"<code>url: str</code>  <code>property</code>","text":"<p>URL of locally hosted server.</p>"},{"location":"api_reference/oauth-flow/#orchestr8.oauth_flow.RedirectServer.intercept","title":"<code>intercept</code>","text":"<p>Intercept incoming request and return its URL. If <code>timeout</code> is None, server waits until a request is intercepted.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>Seconds to wait for. Default: <code>None</code></p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>Intercepted request URL if any, else None</p> Source code in <code>orchestr8/oauth_flow/redirect_server.py</code> <pre><code>def intercept(self, *, timeout: int | None = None) -&gt; str | None:\n    \"\"\"\n    Intercept incoming request and return its URL.\n    If `timeout` is None, server waits until a request is intercepted.\n\n    Args:\n        timeout: Seconds to wait for. Default: `None`\n\n    Returns:\n        Intercepted request URL if any, else None\n    \"\"\"\n    self.raise_if_not_running()\n    time_out_fmt = f\"{timeout}s\" if timeout is not None else \"nil\"\n    self.logger.info(f\"Intercepting request (timeout: &lt;u&gt;{time_out_fmt}&lt;/u&gt;)\")\n\n    self.__instance.timeout = timeout\n    self.__instance.handle_request()\n    return self.__app.last_request_url\n</code></pre>"},{"location":"api_reference/oauth-flow/#orchestr8.oauth_flow.RedirectServer.raise_if_not_running","title":"<code>raise_if_not_running</code>","text":"<p>Raise if server is not running.</p> Source code in <code>orchestr8/oauth_flow/redirect_server.py</code> <pre><code>def raise_if_not_running(self) -&gt; None:\n    \"\"\"Raise if server is not running.\"\"\"\n    if not self.is_running:\n        raise RuntimeError(\"Server not running. use `.start()` method.\")\n</code></pre>"},{"location":"api_reference/oauth-flow/#orchestr8.oauth_flow.RedirectServer.start","title":"<code>start</code>","text":"<p>Start the server.</p> Source code in <code>orchestr8/oauth_flow/redirect_server.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the server.\"\"\"\n    if self.is_running:\n        return\n\n    if not MKCERT_LOCALHOST_SSL_CERT_FILE.is_file() or not MKCERT_LOCALHOST_SSL_PKEY_FILE.is_file():\n        raise FileNotFoundError(\n            \"Certificate or Private key file not found.\\n\\n\"\n            \"Run the following commands to generate it:\\n\"\n            \"mkcert -install # Skip if already done.\\n\"\n            f'mkcert -cert-file \"{MKCERT_LOCALHOST_SSL_CERT_FILE!s}\" '\n            f'-key-file \"{MKCERT_LOCALHOST_SSL_PKEY_FILE!s}\" localhost'\n        )\n\n    WSGIServer.allow_reuse_address = False\n    server_instance = make_server(\n        self.__host,\n        self.__port,\n        self.__app,  # type: ignore[arg-type]\n        handler_class=_WSGIRequestHandler,\n    )\n\n    sslctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    sslctx.check_hostname = False\n    sslctx.load_cert_chain(certfile=MKCERT_LOCALHOST_SSL_CERT_FILE, keyfile=MKCERT_LOCALHOST_SSL_PKEY_FILE)\n    server_instance.socket = sslctx.wrap_socket(sock=server_instance.socket, server_side=True)\n    self.__instance = server_instance\n    self.logger.info(f\"Redirect server started on &lt;u&gt;{self.__host}:{self.__port}&lt;/u&gt;\")\n</code></pre>"},{"location":"api_reference/oauth-flow/#orchestr8.oauth_flow.RedirectServer.stop","title":"<code>stop</code>","text":"<p>Stop the server.</p> Source code in <code>orchestr8/oauth_flow/redirect_server.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the server.\"\"\"\n    if self.is_running:\n        self.logger.info(\"Shutting down the server...\")\n        self.__instance.server_close()\n        self.__instance = None  # type: ignore[assignment]\n</code></pre>"},{"location":"api_reference/sandbox-client/","title":"orchestr8.sandbox_client","text":"<p>A wrapper around docker client for building and running containers.</p> <pre><code>client = SandboxClient()\n\n# Check if image build exists locally\nclient.image_exists(\"ubuntu:22.04\", where=\"local\")\n\n# Check if image is available in registry\nclient.image_exists(\"ubuntu:22.04\", where=\"registry\")\n\n# Pull image from Docker Hub\nclient.build_image(\"ubuntu:22.04\")\n\n# Build image from Dockerfile\nclient.build_image(\"my-image:my-tag\", dockerfile=Path(\"/path/to/Dockerfile\"))\n\n# Run container\ncontainer = client.run_container(\"ubuntu:22.04\", detach=True)\n</code></pre> Source code in <code>orchestr8/sandbox_client.py</code> <pre><code>class SandboxClient(Logger):\n    \"\"\"\n    A wrapper around docker client for building and running containers.\n\n    ```python\n    client = SandboxClient()\n\n    # Check if image build exists locally\n    client.image_exists(\"ubuntu:22.04\", where=\"local\")\n\n    # Check if image is available in registry\n    client.image_exists(\"ubuntu:22.04\", where=\"registry\")\n\n    # Pull image from Docker Hub\n    client.build_image(\"ubuntu:22.04\")\n\n    # Build image from Dockerfile\n    client.build_image(\"my-image:my-tag\", dockerfile=Path(\"/path/to/Dockerfile\"))\n\n    # Run container\n    container = client.run_container(\"ubuntu:22.04\", detach=True)\n    ```\n    \"\"\"\n\n    def __init__(self, **config: Any) -&gt; None:\n        \"\"\"\n        Initialize the client.\n\n        Args:\n            config: Docker client configuration\n        \"\"\"\n        from docker.errors import DockerException  # type: ignore[import-untyped]\n\n        try:\n            import docker  # type: ignore[import-untyped]\n\n            self._instance = docker.DockerClient(**config) if config else docker.from_env()\n        except DockerException as e:\n            if \"The system cannot find the file specified.\" in str(e):\n                raise DockerException(\"Unable to connect. Make sure docker service is running.\") from e\n            raise\n\n    def image_exists(self, image: str, *, where: Literal[\"local\", \"registry\"] = \"local\") -&gt; bool:\n        \"\"\"\n        Check if an image exists.\n\n        Args:\n            image: The image name\n            where: The source to check. Defaults to \"local\"\n\n        Returns:\n            True if the image exists, False otherwise\n        \"\"\"\n        from docker.errors import NotFound\n\n        try:\n            if where == \"local\":  # noqa: SIM108\n                _ = self._instance.images.get(image)\n            else:\n                _ = self._instance.images.get_registry_data(image)\n            return True  # noqa: TRY300\n        except NotFound:\n            return False\n\n    def build_image(self, image: str, *, dockerfile: Path | BytesIO | None = None) -&gt; None:\n        \"\"\"\n        Build an image from pulling it from the registry or building it from a dockerfile.\n\n        Args:\n            image: The image name\n            dockerfile: The dockerfile to build. Defaults to None\n\n        Raises:\n            Exception: If the image not found in the registry\n        \"\"\"\n        if self.image_exists(image, where=\"local\"):\n            self.logger.info(f\"Skipping build process. Image {image!r} already exists.\")\n            return\n\n        if not dockerfile:\n            if not self.image_exists(image, where=\"registry\"):\n                raise Exception(f\"Image {image!r} not found on docker hub.\")\n\n            self.logger.info(f\"Pulling image {image!r} from registry\")\n            _ = self._instance.images.pull(*(s if len(s := image.split(\":\")) == 2 else s[:1]))\n            return\n\n        if isinstance(dockerfile, BytesIO):  # noqa: SIM108\n            fileobj = dockerfile\n        else:\n            fileobj = BytesIO(dockerfile.read_bytes())\n\n        self.logger.info(f\"Building image {image!r} from dockerfile\")\n        for line in self._instance.api.build(fileobj=fileobj, tag=image, rm=True, quiet=False, decode=True):\n            if (log := line.get(\"stream\")) is not None:\n                self.logger.info(log.strip())\n\n    def run_container(  # type: ignore[no-any-unimported]\n        self, image: str, *, volumes: Dict[Path, VolumeValue] | None = None, **run_kwargs: Any\n    ) -&gt; Container:\n        \"\"\"\n        Run a container from a locally available image build.\n        Use `.build_image` before requesting for container instance.\n\n        Args:\n            image: The image to create container instance from\n            volumes: Volumes to mount inside the container. Defaults to None\n            run_kwargs: Keyword arguments to pass to `docker run`\n\n        Returns:\n            The container instance\n\n        Raises:\n            Exception: If the image build is not found\n        \"\"\"\n\n        if not self.image_exists(image, where=\"local\"):\n            raise Exception(f\"Build not found for image {image!r}.\")\n\n        if volumes:\n            run_kwargs[\"volumes\"] = {}\n            for path, vv in volumes.items():\n                run_kwargs[\"volumes\"][str(path)] = vv\n\n        self.logger.info(f\"Starting up container from image {image!r}\")\n        return self._instance.containers.run(image=image, **run_kwargs)\n\n    def copy_path_to_container(self, __id: str, *, src: str | Path, target: str | Path) -&gt; None:\n        \"\"\"\n        Copy a path from the local system to the container.\n\n        Args:\n            __id: Container ID\n            src: Source path in the local system\n            target: Target path inside the container.\n\n        Raises:\n            FileNotFoundError: If the source path does not exist\n        \"\"\"\n        path = Path(src)\n        if not path.exists():\n            raise FileNotFoundError(f\"Source path not found: {path!s}\")\n\n        self.logger.info(f\"Copying {str(path)!r} to {str(target)!r} inside container(sid={__id[:12]!r})\")\n        with BytesIO() as buffer, tar_open(fileobj=buffer, mode=\"w\") as tar:\n            tar.add(path, arcname=path.name)\n            buffer.seek(0)\n\n            self._instance.api.put_archive(__id, path=Path(target).as_posix(), data=buffer)\n</code></pre>"},{"location":"api_reference/sandbox-client/#orchestr8.sandbox_client.SandboxClient.build_image","title":"<code>build_image</code>","text":"<p>Build an image from pulling it from the registry or building it from a dockerfile.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The image name</p> required <code>dockerfile</code> <code>Path | BytesIO | None</code> <p>The dockerfile to build. Defaults to None</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the image not found in the registry</p> Source code in <code>orchestr8/sandbox_client.py</code> <pre><code>def build_image(self, image: str, *, dockerfile: Path | BytesIO | None = None) -&gt; None:\n    \"\"\"\n    Build an image from pulling it from the registry or building it from a dockerfile.\n\n    Args:\n        image: The image name\n        dockerfile: The dockerfile to build. Defaults to None\n\n    Raises:\n        Exception: If the image not found in the registry\n    \"\"\"\n    if self.image_exists(image, where=\"local\"):\n        self.logger.info(f\"Skipping build process. Image {image!r} already exists.\")\n        return\n\n    if not dockerfile:\n        if not self.image_exists(image, where=\"registry\"):\n            raise Exception(f\"Image {image!r} not found on docker hub.\")\n\n        self.logger.info(f\"Pulling image {image!r} from registry\")\n        _ = self._instance.images.pull(*(s if len(s := image.split(\":\")) == 2 else s[:1]))\n        return\n\n    if isinstance(dockerfile, BytesIO):  # noqa: SIM108\n        fileobj = dockerfile\n    else:\n        fileobj = BytesIO(dockerfile.read_bytes())\n\n    self.logger.info(f\"Building image {image!r} from dockerfile\")\n    for line in self._instance.api.build(fileobj=fileobj, tag=image, rm=True, quiet=False, decode=True):\n        if (log := line.get(\"stream\")) is not None:\n            self.logger.info(log.strip())\n</code></pre>"},{"location":"api_reference/sandbox-client/#orchestr8.sandbox_client.SandboxClient.copy_path_to_container","title":"<code>copy_path_to_container</code>","text":"<p>Copy a path from the local system to the container.</p> <p>Parameters:</p> Name Type Description Default <code>__id</code> <code>str</code> <p>Container ID</p> required <code>src</code> <code>str | Path</code> <p>Source path in the local system</p> required <code>target</code> <code>str | Path</code> <p>Target path inside the container.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the source path does not exist</p> Source code in <code>orchestr8/sandbox_client.py</code> <pre><code>def copy_path_to_container(self, __id: str, *, src: str | Path, target: str | Path) -&gt; None:\n    \"\"\"\n    Copy a path from the local system to the container.\n\n    Args:\n        __id: Container ID\n        src: Source path in the local system\n        target: Target path inside the container.\n\n    Raises:\n        FileNotFoundError: If the source path does not exist\n    \"\"\"\n    path = Path(src)\n    if not path.exists():\n        raise FileNotFoundError(f\"Source path not found: {path!s}\")\n\n    self.logger.info(f\"Copying {str(path)!r} to {str(target)!r} inside container(sid={__id[:12]!r})\")\n    with BytesIO() as buffer, tar_open(fileobj=buffer, mode=\"w\") as tar:\n        tar.add(path, arcname=path.name)\n        buffer.seek(0)\n\n        self._instance.api.put_archive(__id, path=Path(target).as_posix(), data=buffer)\n</code></pre>"},{"location":"api_reference/sandbox-client/#orchestr8.sandbox_client.SandboxClient.image_exists","title":"<code>image_exists</code>","text":"<p>Check if an image exists.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The image name</p> required <code>where</code> <code>Literal['local', 'registry']</code> <p>The source to check. Defaults to \"local\"</p> <code>'local'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the image exists, False otherwise</p> Source code in <code>orchestr8/sandbox_client.py</code> <pre><code>def image_exists(self, image: str, *, where: Literal[\"local\", \"registry\"] = \"local\") -&gt; bool:\n    \"\"\"\n    Check if an image exists.\n\n    Args:\n        image: The image name\n        where: The source to check. Defaults to \"local\"\n\n    Returns:\n        True if the image exists, False otherwise\n    \"\"\"\n    from docker.errors import NotFound\n\n    try:\n        if where == \"local\":  # noqa: SIM108\n            _ = self._instance.images.get(image)\n        else:\n            _ = self._instance.images.get_registry_data(image)\n        return True  # noqa: TRY300\n    except NotFound:\n        return False\n</code></pre>"},{"location":"api_reference/sandbox-client/#orchestr8.sandbox_client.SandboxClient.run_container","title":"<code>run_container</code>","text":"<p>Run a container from a locally available image build. Use <code>.build_image</code> before requesting for container instance.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The image to create container instance from</p> required <code>volumes</code> <code>Dict[Path, VolumeValue] | None</code> <p>Volumes to mount inside the container. Defaults to None</p> <code>None</code> <code>run_kwargs</code> <code>Any</code> <p>Keyword arguments to pass to <code>docker run</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>Container</code> <p>The container instance</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the image build is not found</p> Source code in <code>orchestr8/sandbox_client.py</code> <pre><code>def run_container(  # type: ignore[no-any-unimported]\n    self, image: str, *, volumes: Dict[Path, VolumeValue] | None = None, **run_kwargs: Any\n) -&gt; Container:\n    \"\"\"\n    Run a container from a locally available image build.\n    Use `.build_image` before requesting for container instance.\n\n    Args:\n        image: The image to create container instance from\n        volumes: Volumes to mount inside the container. Defaults to None\n        run_kwargs: Keyword arguments to pass to `docker run`\n\n    Returns:\n        The container instance\n\n    Raises:\n        Exception: If the image build is not found\n    \"\"\"\n\n    if not self.image_exists(image, where=\"local\"):\n        raise Exception(f\"Build not found for image {image!r}.\")\n\n    if volumes:\n        run_kwargs[\"volumes\"] = {}\n        for path, vv in volumes.items():\n            run_kwargs[\"volumes\"][str(path)] = vv\n\n    self.logger.info(f\"Starting up container from image {image!r}\")\n    return self._instance.containers.run(image=image, **run_kwargs)\n</code></pre>"},{"location":"api_reference/shell/","title":"orchestr8.shell","text":""},{"location":"api_reference/shell/#shell-host-based","title":"Shell (host-based)","text":"<p>Interface for running commands in host machine.</p> <p>If host is windows, all commands are executed using <code>PowerShell</code>.</p> <p>\u26a0\ufe0f WARNING: This class allows execution of system commands and should be used with EXTREME CAUTION.</p> <ul> <li>Never run commands with user-supplied or untrusted input</li> <li>Always validate and sanitize any command arguments</li> <li>Be aware of potential security risks, especially with privilege escalation</li> </ul> <pre><code># Initialize the shell\nshell = Shell(workdir=\"/path/to/directory\")\n\n# Run command\nprint(shell.run(\"echo\", \"'Hello from shell!'\"))\n\n# Stream run command\nfor line in shell.stream(\"echo\", \"Hello from shell!\"):\n    print(line)\n</code></pre> Source code in <code>orchestr8/shell.py</code> <pre><code>class Shell(Logger):\n    \"\"\"\n    Interface for running commands in host machine.\n\n    If host is windows, all commands are executed using `PowerShell`.\n\n    \u26a0\ufe0f WARNING: This class allows execution of system commands and should be used with EXTREME CAUTION.\n\n    - Never run commands with user-supplied or untrusted input\n    - Always validate and sanitize any command arguments\n    - Be aware of potential security risks, especially with privilege escalation\n\n    ```python\n    # Initialize the shell\n    shell = Shell(workdir=\"/path/to/directory\")\n\n    # Run command\n    print(shell.run(\"echo\", \"'Hello from shell!'\"))\n\n    # Stream run command\n    for line in shell.stream(\"echo\", \"Hello from shell!\"):\n        print(line)\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        workdir: str | Path | None = None,\n        raise_on_non_zero: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the CommandExecutor.\n\n        Args:\n            workdir: The working directory to execute commands in\n            raise_on_non_zero: Whether to raise an exception if the command returns non-zero exit code\n        \"\"\"\n        if workdir:\n            w_dir = Path(workdir)\n            if not w_dir.is_dir():\n                raise NotADirectoryError(f\"{str(w_dir)!r} is not a directory.\")\n            self.__workdir = PurePath(w_dir)\n        else:\n            self.__workdir = PurePath(Path.cwd())\n\n        self.__raise_on_non_zero = raise_on_non_zero\n\n    @staticmethod\n    def __validate_cmd(cmd: Tuple[str, ...]) -&gt; Tuple[str, ...]:\n        if os.name == \"nt\" and \"SHELL\" not in os.environ:\n            return (\"powershell\", \"-NoProfile\", \"-NonInteractive\", \"-Command\", *cmd)\n        return cmd\n\n    @property\n    def workdir(self) -&gt; PurePath:\n        \"\"\"The working directory.\"\"\"\n        return self.__workdir\n\n    def __prepare_common_kwargs(self, env: Dict[str, str] | None = None) -&gt; Dict[str, Any]:\n        kwargs = {\"cwd\": self.__workdir, \"text\": True}\n        if env:\n            kwargs[\"env\"] = {**os.environ, **env}\n        return kwargs\n\n    def run(self, *cmd: str, env: Dict[str, str] | None = None) -&gt; str | None:\n        \"\"\"\n        Run a command and return the output.\n\n        Args:\n            cmd: The arguments to pass as command\n            env: Environment variables to set\n\n        Returns:\n            Output of the executed command\n\n        Raises:\n            ShellException: If the command returns non-zero exit code and raise_on_non_zero is False\n        \"\"\"\n        self.logger.info(format_log(cmd))\n        process: subprocess.CompletedProcess[str] = subprocess.run(  # noqa: S603\n            self.__validate_cmd(cmd), capture_output=True, **self.__prepare_common_kwargs(env)\n        )\n        if error := process.stderr.strip():\n            if process.returncode != 0 and self.__raise_on_non_zero:\n                raise_on_failure(cmd, error)\n            return error\n\n        return process.stdout.strip() or None\n\n    def stream(self, *cmd: str, env: Dict[str, str] | None = None) -&gt; Generator[str, Any, None]:\n        \"\"\"\n        Run a command and stream the output.\n\n        Args:\n            cmd: The arguments to pass as command\n            env: Environment variables to set\n\n        Returns:\n            Output stream of the executed command\n\n        Raises:\n            ShellException: If the command returns non-zero exit code and raise_on_non_zero is False\n        \"\"\"\n        self.logger.info(format_log(cmd))\n        process = subprocess.Popen(  # noqa: S603\n            self.__validate_cmd(cmd),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            **self.__prepare_common_kwargs(env),\n        )\n        if error := process.stderr:\n            if process.returncode != 0 and self.__raise_on_non_zero:\n                raise_on_failure(cmd, \"\".join(error).strip())\n            yield from error\n\n        if output := process.stdout:\n            yield from output\n</code></pre>"},{"location":"api_reference/shell/#orchestr8.shell.Shell.workdir","title":"<code>workdir: PurePath</code>  <code>property</code>","text":"<p>The working directory.</p>"},{"location":"api_reference/shell/#orchestr8.shell.Shell.run","title":"<code>run</code>","text":"<p>Run a command and return the output.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The arguments to pass as command</p> <code>()</code> <code>env</code> <code>Dict[str, str] | None</code> <p>Environment variables to set</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>Output of the executed command</p> <p>Raises:</p> Type Description <code>ShellException</code> <p>If the command returns non-zero exit code and raise_on_non_zero is False</p> Source code in <code>orchestr8/shell.py</code> <pre><code>def run(self, *cmd: str, env: Dict[str, str] | None = None) -&gt; str | None:\n    \"\"\"\n    Run a command and return the output.\n\n    Args:\n        cmd: The arguments to pass as command\n        env: Environment variables to set\n\n    Returns:\n        Output of the executed command\n\n    Raises:\n        ShellException: If the command returns non-zero exit code and raise_on_non_zero is False\n    \"\"\"\n    self.logger.info(format_log(cmd))\n    process: subprocess.CompletedProcess[str] = subprocess.run(  # noqa: S603\n        self.__validate_cmd(cmd), capture_output=True, **self.__prepare_common_kwargs(env)\n    )\n    if error := process.stderr.strip():\n        if process.returncode != 0 and self.__raise_on_non_zero:\n            raise_on_failure(cmd, error)\n        return error\n\n    return process.stdout.strip() or None\n</code></pre>"},{"location":"api_reference/shell/#orchestr8.shell.Shell.stream","title":"<code>stream</code>","text":"<p>Run a command and stream the output.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The arguments to pass as command</p> <code>()</code> <code>env</code> <code>Dict[str, str] | None</code> <p>Environment variables to set</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Output stream of the executed command</p> <p>Raises:</p> Type Description <code>ShellException</code> <p>If the command returns non-zero exit code and raise_on_non_zero is False</p> Source code in <code>orchestr8/shell.py</code> <pre><code>def stream(self, *cmd: str, env: Dict[str, str] | None = None) -&gt; Generator[str, Any, None]:\n    \"\"\"\n    Run a command and stream the output.\n\n    Args:\n        cmd: The arguments to pass as command\n        env: Environment variables to set\n\n    Returns:\n        Output stream of the executed command\n\n    Raises:\n        ShellException: If the command returns non-zero exit code and raise_on_non_zero is False\n    \"\"\"\n    self.logger.info(format_log(cmd))\n    process = subprocess.Popen(  # noqa: S603\n        self.__validate_cmd(cmd),\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        **self.__prepare_common_kwargs(env),\n    )\n    if error := process.stderr:\n        if process.returncode != 0 and self.__raise_on_non_zero:\n            raise_on_failure(cmd, \"\".join(error).strip())\n        yield from error\n\n    if output := process.stdout:\n        yield from output\n</code></pre>"},{"location":"api_reference/shell/#isolatedshell","title":"IsolatedShell","text":"<p>Interface for running commands inside a detached container.</p> <pre><code>from orchestr8.sandbox_client import SandboxClient\n\n# Create a detached container\nclient = SandboxClient()\ncontainer = client.run_container(\n    \"ubuntu:22.04\", detach=True, remove=True\n)\n\n# Initialize the shell\nshell = IsolatedShell(\n    container=container, workdir=\"/path/to/directory\"\n)\n\n# Run command\nprint(shell.run(\"echo\", \"Hello from shell!\"))\n\n# Stream run command\nfor line in shell.stream(\"ls\", \"-l\"):\n    print(line)\n</code></pre> Source code in <code>orchestr8/shell.py</code> <pre><code>class IsolatedShell(Logger):\n    \"\"\"\n    Interface for running commands inside a detached container.\n\n    ```python\n    from orchestr8.sandbox_client import SandboxClient\n\n    # Create a detached container\n    client = SandboxClient()\n    container = client.run_container(\n        \"ubuntu:22.04\", detach=True, remove=True\n    )\n\n    # Initialize the shell\n    shell = IsolatedShell(\n        container=container, workdir=\"/path/to/directory\"\n    )\n\n    # Run command\n    print(shell.run(\"echo\", \"Hello from shell!\"))\n\n    # Stream run command\n    for line in shell.stream(\"ls\", \"-l\"):\n        print(line)\n    ```\n    \"\"\"\n\n    def __init__(  # type: ignore[no-any-unimported]\n        self,\n        *,\n        container: Container,\n        workdir: str | Path | None = None,\n        raise_on_non_zero: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            container: The detached container to execute commands in\n            workdir: The working directory to execute commands in\n            raise_on_non_zero: Whether to raise an exception if the command returns non-zero exit co\n        \"\"\"\n        container.reload()\n        if container.status != \"running\":\n            raise ShellException(\"Container is not running.\")\n        self.__container = container\n        self.__w_dir_str = None\n        self.__raise_on_non_zero = raise_on_non_zero\n        if workdir:\n            self.__workdir = PurePath(workdir)\n        else:\n            self.__workdir = PurePath(self.run(\"pwd\").strip())  # type: ignore[union-attr]\n        self.__w_dir_str = self.__workdir.as_posix()\n\n    @property\n    def container(self) -&gt; Container:  # type: ignore[no-any-unimported]\n        \"\"\"The container.\"\"\"\n        return self.__container\n\n    @property\n    def workdir(self) -&gt; PurePath:\n        \"\"\"The working directory.\"\"\"\n        return self.__workdir\n\n    def __exec(self, *cmd: str, **kwargs: Any) -&gt; Any:\n        self.logger.info(format_log(cmd))\n        code, ret = self.__container.exec_run(cmd, workdir=self.__w_dir_str, **kwargs)\n        if code != 0 and self.__raise_on_non_zero:\n            self._stop_container()  # Is it right to stop the container before raising exception?\n            raise_on_failure(cmd, ret)\n        return ret\n\n    def run(self, *cmd: str, env: Dict[str, str] | None = None) -&gt; str | None:\n        \"\"\"\n        Run a command inside the container and return the output.\n\n        Args:\n            cmd: The arguments to pass as command\n            env: Environment variables to set\n\n        Returns:\n            Output of the executed command\n\n        Raises:\n            ShellException: If the command returns non-zero exit code and raise_on_non_zero is False\n        \"\"\"\n        return self.__exec(*cmd, environment=env).decode() or None\n\n    def stream(self, *cmd: str, env: Dict[str, str] | None = None) -&gt; Generator[str, Any, None]:\n        \"\"\"\n        Run a command in the container and stream the output.\n\n        Args:\n            cmd: The arguments to pass as command\n            env: Environment variables to set\n\n        Returns:\n            Output stream of the executed command\n\n        Raises:\n            ShellException: If the command returns non-zero exit code and raise_on_non_zero is False\n        \"\"\"\n        for line in self.__exec(*cmd, stream=True, environment=env):\n            yield line.decode()\n\n    def _stop_container(self) -&gt; None:\n        \"\"\"Stop the container.\"\"\"\n        if self.__container.status == \"running\":\n            self.logger.info(\"Shutting down the container\")\n            self.__container.stop()\n\n    def __del__(self) -&gt; None:\n        self._stop_container()\n</code></pre>"},{"location":"api_reference/shell/#orchestr8.shell.IsolatedShell.container","title":"<code>container: Container</code>  <code>property</code>","text":"<p>The container.</p>"},{"location":"api_reference/shell/#orchestr8.shell.IsolatedShell.workdir","title":"<code>workdir: PurePath</code>  <code>property</code>","text":"<p>The working directory.</p>"},{"location":"api_reference/shell/#orchestr8.shell.IsolatedShell.run","title":"<code>run</code>","text":"<p>Run a command inside the container and return the output.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The arguments to pass as command</p> <code>()</code> <code>env</code> <code>Dict[str, str] | None</code> <p>Environment variables to set</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>Output of the executed command</p> <p>Raises:</p> Type Description <code>ShellException</code> <p>If the command returns non-zero exit code and raise_on_non_zero is False</p> Source code in <code>orchestr8/shell.py</code> <pre><code>def run(self, *cmd: str, env: Dict[str, str] | None = None) -&gt; str | None:\n    \"\"\"\n    Run a command inside the container and return the output.\n\n    Args:\n        cmd: The arguments to pass as command\n        env: Environment variables to set\n\n    Returns:\n        Output of the executed command\n\n    Raises:\n        ShellException: If the command returns non-zero exit code and raise_on_non_zero is False\n    \"\"\"\n    return self.__exec(*cmd, environment=env).decode() or None\n</code></pre>"},{"location":"api_reference/shell/#orchestr8.shell.IsolatedShell.stream","title":"<code>stream</code>","text":"<p>Run a command in the container and stream the output.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The arguments to pass as command</p> <code>()</code> <code>env</code> <code>Dict[str, str] | None</code> <p>Environment variables to set</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Output stream of the executed command</p> <p>Raises:</p> Type Description <code>ShellException</code> <p>If the command returns non-zero exit code and raise_on_non_zero is False</p> Source code in <code>orchestr8/shell.py</code> <pre><code>def stream(self, *cmd: str, env: Dict[str, str] | None = None) -&gt; Generator[str, Any, None]:\n    \"\"\"\n    Run a command in the container and stream the output.\n\n    Args:\n        cmd: The arguments to pass as command\n        env: Environment variables to set\n\n    Returns:\n        Output stream of the executed command\n\n    Raises:\n        ShellException: If the command returns non-zero exit code and raise_on_non_zero is False\n    \"\"\"\n    for line in self.__exec(*cmd, stream=True, environment=env):\n        yield line.decode()\n</code></pre>"},{"location":"cookbooks/","title":"Cookbooks","text":"<p>Welcome to our collection of cookbooks showcasing the power of orchestr8 library in Language Model workflows. These notebooks demonstrate how to effectively use orchestr8 to solve simple but critical problems.</p>"},{"location":"cookbooks/#quick-links","title":"Quick Links","text":"<ul> <li> <p>Running LLM-generated code: Executing LLM-generated code in a controlled, isolated virtual environments.</p> </li> <li> <p>Function-Calling automation: Automated approach to working with function-calling workflows.</p> </li> <li> <p>Version Control &amp; Function-Calling: Safe and controlled file system interactions through function-calling.</p> </li> <li> <p>Authentication &amp; Function-Calling: OAuth Flow and connecting with APIs through function-calling.</p> </li> </ul>"},{"location":"cookbooks/authentication-and-function-calling/","title":"Authentication & Function-Calling","text":"<p>Modern applications often rely on third-party services to extend their capabilities, but securing and managing authentication can be a significant technical challenge. OAuth has become the standard protocol for secure, delegated access, yet implementing it correctly requires handling complex token exchanges, refresh mechanisms, and secure credential management.</p> <p>This cookbook demonstrates how to simplify OAuth authentication within function-calling workflows, providing a streamlined approach to securely connecting and accessing external service APIs.</p>"},{"location":"cookbooks/authentication-and-function-calling/#installation-and-setup","title":"Installation and Setup","text":"<p>This cookbook requires the <code>litellm</code> library for function-call generation via the Groq provider.</p> <p>If you don't have an API key for Groq, you can get one at Groq Console.</p> <p><code>OAuthFlow</code> component requires <code>mkcert</code> for setting up local redirect server, refer here for installation instructions</p> <pre><code>%pip install orchestr8[adapter] litellm requests\n\nimport os, getpass\n\ndef set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\nset_env(\"GROQ_API_KEY\")\n</code></pre> <pre><code>import json\nfrom typing import Any, Dict, List\n\nfrom litellm import completion\n\nINSTRUCTION = \"Complete user requests using the given functions.\"\n\ndef generate_function_call(request: str, functions: List[Dict[str, Any]]):\n    response = completion(\n        model=\"groq/llama3-groq-70b-8192-tool-use-preview\",\n        messages=[\n            {\"role\": \"system\", \"content\": INSTRUCTION},\n            {\"role\": \"user\", \"content\": request}\n        ],\n        tools=functions\n    )\n    tool_call = response.choices[0].message.tool_calls[0].function\n    if tool_call is None:\n        print(response.choices[0].message.content)\n        raise Exception(\"No function call found in the response.\")\n    return tool_call.name, json.loads(tool_call.arguments)\n</code></pre>"},{"location":"cookbooks/authentication-and-function-calling/#creating-an-oauth-flow","title":"Creating an OAuth Flow","text":"<p>Here, we'll create an OAuth flow for the <code>discord</code> service. This flow will allow us to authenticate with Discord and obtain an access token. In later steps, we'll use this access token to access the Discord API through function calls.</p> <pre><code>import orchestr8 as o8\nimport requests\n\nclass DiscordOAuthFlow(o8.OAuthFlow):\n    \"\"\"Class for handling Discord OAuth2 flow.\"\"\"\n\n    @property\n    def auth_url(self) -&gt; str:\n        \"\"\"\n        Formatted Discord authorization URL for getting code.\n        \"\"\"\n        return (\n            f\"https://discord.com/api/oauth2/authorize\"\n            f\"?client_id={self.client_id}&amp;redirect_uri={self.quoted_redirect_url}\"\n            f\"&amp;response_type=code&amp;scope={self.user_scopes}\"\n        )\n\n    def _generate_access_token(self, code: str) -&gt; str:\n        \"\"\"\n        Generate an access token from the authorization code.\n\n        :param code: Authorization code from Discord.\n        :return: The access token.\n        \"\"\"\n        response = requests.post(\n            \"https://discord.com/api/oauth2/token\",\n            data={\n                'grant_type': 'authorization_code',\n                'code': code,\n                'redirect_uri': self.redirect_url,\n            },\n            headers={'Content-Type': 'application/x-www-form-urlencoded'},\n            auth=(self.client_id, self.client_secret)\n        )\n\n        if response.status_code != 200:\n            raise Exception(f\"Failed to obtain access token: {response.json()}\")\n\n        return response.json()['access_token']\n\ndiscord_flow = DiscordOAuthFlow(\n    client_id=\"&lt;client-id&gt;\",\n    client_secret=\"&lt;client-secret&gt;\",\n    user_scopes=\"identify email guilds\",\n)\naccess_token = discord_flow.authorize(timeout=30)\n</code></pre> <p>Logs</p> <pre><code>[DiscordOAuthFlow] Starting authorization process\n[RedirectServer] Redirect server started on localhost:41539\n[DiscordOAuthFlow] Add this URL to your application's redirect settings: https://localhost:41539/\n[DiscordOAuthFlow] Click this URL to authorize: https://discord.com/api/oauth2/authorize?client_id=&lt;client-id&gt;&amp;redirect_uri=https%3A%2F%2Flocalhost%3A41539%2F&amp;response_type=code&amp;scope=identify+email+guilds\n[RedirectServer] Intercepting request (timeout: 30s)\n[DiscordOAuthFlow] Authorization code received\n[DiscordOAuthFlow] Access token generated successfully\n</code></pre> <p>To generate client id and secret, refer discord oauth2 docs or directly go to discord developer portal</p>"},{"location":"cookbooks/authentication-and-function-calling/#creating-adapters-from-functions","title":"Creating adapters from functions","text":"<p>Creating adapters is as simple as defining a function and decorating it with <code>@adapt</code> decorator.</p> <pre><code>import orchestr8 as o8\nimport requests\n\n@o8.adapt\ndef fetch_my_discord_info():\n    \"\"\"Fetch my information from the Discord API.\"\"\"\n    headers = {\n        'Authorization': f'Bearer {access_token}',\n        'Content-Type': 'application/json'\n    }\n\n    response = requests.get('https://discord.com/api/v9/users/@me', headers=headers)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise Exception(f'Failed to fetch user info: {response.status_code} - {response.text}')\n\n@o8.adapt\ndef fetch_my_discord_guilds():\n    \"\"\"Fetch the guilds that I am a member of on Discord.\"\"\"\n    headers = {\n        'Authorization': f'Bearer {access_token}',\n        'Content-Type': 'application/json'\n    }\n\n    response = requests.get('https://discord.com/api/v9/users/@me/guilds', headers=headers)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise Exception(f'Failed to fetch user guilds: {response.status_code} - {response.text}')\n</code></pre>"},{"location":"cookbooks/authentication-and-function-calling/#generating-function-call","title":"Generating function-call","text":"<p>There are three available function-calling schema formats: OpenAI, Anthropic, and Gemini.</p> <p>We'll be using OpenAI schema for this example as we're using Llama model.</p> <pre><code>function_call = generate_function_call(\n    \"Fetch my discord info\",\n    functions=[fetch_my_discord_info.openai_schema, fetch_my_discord_guilds.openai_schema],\n)\nprint(function_call)\n</code></pre> <p>Result</p> <pre><code>('fetch_my_discord_info', {})\n</code></pre> <p>Now, we can utilize the <code>validate_input</code> method to send the message to the specified discord channel.</p> <pre><code>fetch_my_discord_info.validate_input(function_call[1])\n</code></pre> <p>Result</p> <pre><code>{\n    'id': '1260905671142936631',\n    'username': 'synacktra._81487',\n    'avatar': None,\n    'discriminator': '0',\n    'public_flags': 0,\n    'flags': 0,\n    'banner': None,\n    'accent_color': None,\n    'global_name': 'synacktra',\n    'avatar_decoration_data': None,\n    'banner_color': None,\n    'clan': None,\n    'primary_guild': None,\n    'mfa_enabled': True,\n    'locale': 'en-US',\n    'premium_type': 0,\n    'email': 'synacktra.work@gmail.com',\n    'verified': True\n}\n</code></pre>"},{"location":"cookbooks/function-calling-automation/","title":"Function-Calling automation","text":"<p>Function calling introduces powerful capabilities to interact with AI models, but manually creating and maintaining function schemas is a complex and error-prone process. Developers often struggle with:</p> <ul> <li>Keeping schemas synchronized with code changes</li> <li>Ensuring type safety and input validation</li> <li>Supporting multiple AI platform formats</li> <li>Reducing repetitive boilerplate code</li> </ul> <p>This cookbook demonstrates an automated approach to generating and managing function-calling schemas, streamlining the integration between your code and Language Models.</p>"},{"location":"cookbooks/function-calling-automation/#installation-and-setup","title":"Installation and Setup","text":"<p>This cookbook requires the <code>litellm</code> library for function-call generation via the Groq provider.</p> <p>If you don't have an API key for Groq, you can get one at Groq Console.</p> <pre><code>%pip install orchestr8[adapter] litellm duckduckgo-search\n\nimport os, getpass\n\ndef set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\nset_env(\"GROQ_API_KEY\")\n</code></pre> <pre><code>import json\nfrom typing import Any, Dict, List\n\nfrom litellm import completion\n\nINSTRUCTION = \"Complete user requests using the given functions.\"\n\ndef generate_function_call(request: str, functions: List[Dict[str, Any]]):\n    response = completion(\n        model=\"groq/llama3-groq-70b-8192-tool-use-preview\",\n        messages=[\n            {\"role\": \"system\", \"content\": INSTRUCTION},\n            {\"role\": \"user\", \"content\": request}\n        ],\n        tools=functions\n    )\n    tool_call = response.choices[0].message.tool_calls[0].function\n    if tool_call is None:\n        print(response.choices[0].message.content)\n        raise Exception(\"No function call found in the response.\")\n    return tool_call.name, json.loads(tool_call.arguments)\n</code></pre>"},{"location":"cookbooks/function-calling-automation/#creating-adapters-from-functions","title":"Creating adapters from functions","text":"<p>Creating adapters is as simple as defining a function and decorating it with <code>@adapt</code> decorator.</p> <pre><code>from typing import Literal\n\nimport orchestr8 as o8\nfrom duckduckgo_search import DDGS\n\n\nddgs = DDGS()\n\n@o8.adapt\ndef search_text(\n    text: str,\n    *, # Yes it supports positional and keyword arguments\n    safe_search: bool = True,\n    backend: Literal['api', 'html', 'lite'] = 'api',\n    max_results: int = 1\n):\n    \"\"\"\n    Search for text in the web.\n    :param text: Text to search for.\n    :param safe_search: If True, enable safe search.\n    :param backend: Backend to use for retrieving results.\n    :param max_results: Max results to return.\n    \"\"\"\n    return ddgs.text(\n        keywords=text,\n        safesearch=\"on\" if safe_search else \"off\",\n        backend=backend,\n        max_results=max_results\n    )\n\n\n@o8.adapt\ndef get_translation(\n    text: str,\n    to: Literal['en', 'ja', 'hi', 'es', 'fr', 'de', 'zh'] = 'en'\n):\n    \"\"\"\n    Translate the given text.\n    :param text: Text to translate.\n    :param to: what language to translate.\n    \"\"\"\n    return ddgs.translate(keywords=text, to=to)\n</code></pre>"},{"location":"cookbooks/function-calling-automation/#generating-function-calls","title":"Generating function-calls","text":"<p>There are three available function-calling schema formats: OpenAI, Anthropic, and Gemini.</p> <p>We'll be using OpenAI schema for this example as we're using Llama model.</p> <pre><code>function_call = generate_function_call(\n    \"Search for the best restaurants in Kolkata.\",\n    functions=[search_text.openai_schema, get_translation.openai_schema],\n)\nprint(function_call)\n</code></pre> <p>Result</p> <pre><code>('search_text', {'text': 'best restaurants in Kolkata', 'max_results': 5, 'safe_search': True})\n</code></pre> <p>Now, we can utilize the <code>validate_input</code> method to validate the function arguments generated by the LLM.</p> <pre><code>search_results = search_text.validate_input(function_call[1])\nfor entry in search_results:\n    print(entry)\n</code></pre> <p>Result</p> <pre><code>{'title': 'THE 10 BEST Restaurants in Kolkata (Calcutta) (Updated 2024) - Tripadvisor', 'href': 'https://www.tripadvisor.in/Restaurants-g304558-Kolkata_Calcutta_Kolkata_District_West_Bengal.html', 'body': 'Dining in Kolkata (Calcutta), Kolkata District: See 63,234 Tripadvisor traveller reviews of 5,724 Kolkata (Calcutta) restaurants and search by cuisine, price, location, and more.'}\n{'title': 'The 31 Best Restaurants in Kolkata (Calcutta), India - Eater', 'href': 'https://www.eater.com/maps/best-restaurants-kolkata-calcutta-india-bengal', 'body': 'The 31 Essential Kolkata Restaurants. Deviled crabs at a midcentury cabaret, phuchka from a decades-old street vendor, and more of the best things to eat in Kolkata'}\n{'title': 'The 50 best restaurants in Kolkata - Cond\u00e9 Nast Traveller India', 'href': 'https://www.cntraveller.in/magazine-story/kolkatas-50-best-meals/', 'body': \"Explore the diverse cuisines of Kolkata, from Bengali sweet shops to Mughlai, Chinese and Continental restaurants. Discover the history, culture and flavours of the city's top dining spots, from Flurys to Kewpie's Kitchen.\"}\n{'title': 'The 11 Best Restaurants in Kolkata - TripSavvy', 'href': 'https://www.tripsavvy.com/best-restaurants-in-kolkata-5176449', 'body': \"Discover the diverse cuisines and dining scenes of Kolkata, from Bengali fine dining to modern Indian and heritage continental. Find out the best places to enjoy seafood, kebabs, biryani, and more in the city's iconic areas.\"}\n{'title': '14 Best Restaurants in Kolkata (2024) - WanderOn', 'href': 'https://wanderon.in/blogs/best-restaurants-in-kolkata', 'body': 'Explore the diverse and vibrant food scene of Kolkata, from traditional Bengali cuisine to continental dishes, street food, and international flavors. Discover the best restaurants in Kolkata, ranging from historic institutions to quirky cafes and local eateries, and enjoy a gastronomic adventure.'}\n</code></pre> <p>Adapters also has as interesting property <code>.definition</code> which returns the code definition of the function.</p> <p>It can be useful in cases where you want to pass the function as context to the LLM.</p> <pre><code>print(get_translation.definition)\n</code></pre> <p>Result</p> <pre><code>def get_translation(text: str, to: Literal['en', 'ja', 'hi', 'es', 'fr', 'de', 'zh']='en'):\n    \"\"\"\n    Translate the given text.\n    :param text: Text to translate.\n    :param to: what language to translate.\n    \"\"\"\n    return ddgs.translate(keywords=text, to=to)\n</code></pre>"},{"location":"cookbooks/running-llm-generated-code/","title":"Running LLM-generated code","text":"<p>Let's face it: Large Language Models (LLMs) are brilliant at generating code, but they're not infallible. They can hallucinate functions, introduce security risks, and occasionally produce code that looks convincing but is fundamentally broken.</p> <p>This cookbook is your safety net. We'll explore how to execute LLM-generated code in a controlled, isolated environment\u2014transforming your skepticism into a structured approach for safe code exploration.</p> <p>Think of it like handling a fascinating but unpredictable exotic pet: you want to marvel at its capabilities while ensuring it can't accidentally wreck your entire digital ecosystem.</p>"},{"location":"cookbooks/running-llm-generated-code/#installation-and-setup","title":"Installation and Setup","text":"<p>Make sure you have <code>docker</code> installed on your system. Refer to the docker installation guide for more details.</p> <p>This cookbook requires the <code>litellm</code> library for code generation via the Groq provider.</p> <p>If you don't have an API key for Groq, you can get one at Groq Console.</p> <pre><code>%pip install orchestr8[execution-runtime] litellm\n\nimport os, getpass\n\ndef set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\nset_env(\"GROQ_API_KEY\")\n</code></pre> <pre><code>import re\nfrom io import BytesIO\n\nfrom litellm import completion\n\n# Yoinked from https://github.com/ShishirPatil/gorilla/blob/main/goex/exec_engine/pipeline.py#L14\nINSTRUCTION = \"\"\"\\\nYou are an assistant that outputs executable Python code that perform what the user requests.\nIt is important that you only return one and only one code block with all the necessary imports inside ```python and nothing else.\nThe code block should print the output(s) when appropriate.\n\nIf the action can't be successfully completed, throw an exception.\n\"\"\"\n\ndef generate_code(request: str) -&gt; BytesIO | None:\n    response = completion(\n        model=\"groq/llama-3.1-70b-versatile\",\n        messages=[\n            {\"role\": \"system\", \"content\": INSTRUCTION},\n            {\"role\": \"user\", \"content\": request}\n        ],\n    )\n    content: str = response.choices[0].message.content\n    match = re.search(r\"```python\\n(.*?)```\", content, re.DOTALL) # search for the code block\n    if match:\n        # extract the code block\n        code = match.group(1)\n        print(code)\n        return BytesIO(code.encode())\n</code></pre>"},{"location":"cookbooks/running-llm-generated-code/#creating-an-isolated-runtime","title":"Creating an isolated runtime","text":"<p>Execution runtime uses <code>uv</code> to run python scripts and projects inside virtual environments.</p> <pre><code>import orchestr8 as o8\n\nruntime = o8.create_execution_runtime(isolate=True)\n</code></pre> <p>The first time you run this, it will take a minute or two to setup the container.</p> <p>Logs</p> <pre><code>[IsolatedExecutionRuntime] Setting up the instance\n[SandboxClient] Building image 'orchestr8-runtime:py-3.10-alpine3.20' from dockerfile\n[SandboxClient] Step 1/3 : FROM python:3.10-alpine3.20\n[SandboxClient]\n[SandboxClient] ---&gt; 039508c234f8\n[SandboxClient] Step 2/3 : COPY --from=ghcr.io/astral-sh/uv:latest /uv /bin/uv\n[SandboxClient]\n[SandboxClient] ---&gt; 1cc5c59fffc4\n[SandboxClient] Step 3/3 : CMD [\"tail\", \"-f\", \"/dev/null\"]\n[SandboxClient]\n[SandboxClient] ---&gt; Running in 48e67352a232\n[SandboxClient] ---&gt; Removed intermediate container 48e67352a232\n[SandboxClient] ---&gt; d92b0d627dbe\n[SandboxClient] Successfully built d92b0d627dbe\n[SandboxClient] Successfully tagged orchestr8-runtime:py-3.10-alpine3.20\n[SandboxClient] Starting up container from image 'orchestr8-runtime:py-3.10-alpine3.20'\n</code></pre>"},{"location":"cookbooks/running-llm-generated-code/#generating-and-running-the-code","title":"Generating and running the code","text":"<p>We're going to ask a query where the LLM includes a third party library in the generated code to show why running the code using orchestr8's execution runtime is beneficial.</p> <pre><code>code = generate_code(\"\"\"\\\nWrite a python function that uses requests library to fetch github user information.\nInclude an example of fetching the user \"synacktraa\".\n\"\"\")\n</code></pre> <p>Result</p> <pre><code>import requests\nimport json\n\ndef fetch_github_user_info(username):\n    try:\n        url = f\"https://api.github.com/users/{username}\"\n        response = requests.get(url)\n\n        if response.status_code == 200:\n            user_info = response.json()\n            print(json.dumps(user_info, indent=4))\n        else:\n            raise Exception(f\"Failed to fetch user information. Status code: {response.status_code}\")\n    except requests.exceptions.RequestException as e:\n        raise Exception(f\"An error occurred: {e}\")\n\nfetch_github_user_info(\"synacktraa\")\n</code></pre> <p>To run this code inside the runtime, we can use the <code>run_script</code> method.</p> <p>The <code>run_script</code> creates an on-demand environment for the script and runs it inside it. It also installs the third party dependencies (if any) specified in the script.</p> <pre><code>output = runtime.run_script(code, requirements=True)\nprint(output)\n</code></pre> <p>If you take a look at the third log message, you'll notice that the script is ran with <code>requests==2.32.3</code> dependency. If you wish to know more about this <code>auto-generation</code> of requirements, refer <code>generate_requirements</code> function.</p> <p>Logs and Result</p> <pre><code>[SandboxClient] Copying 'C:\\\\Users\\\\synac\\\\AppData\\\\Local\\\\Temp\\\\tmpwz_hvchz.py' to '/tmp' inside container(sid='de0a74e929ce')\n[IsolatedExecutionRuntime] Running script 'tmpwz_hvchz.py'\n[IsolatedShell] \u2699\ufe0f  || uv run --no-project --quiet --with requests==2.32.3 /tmp/tmpwz_hvchz.py\n{\n    \"login\": \"synacktraa\",\n    \"id\": 91981716,\n    \"node_id\": \"U_kgDOBXuHlA\",\n    \"avatar_url\": \"https://avatars.githubusercontent.com/u/91981716?v=4\",\n    \"gravatar_id\": \"\",\n    \"url\": \"https://api.github.com/users/synacktraa\",\n    \"html_url\": \"https://github.com/synacktraa\",\n    \"followers_url\": \"https://api.github.com/users/synacktraa/followers\",\n    \"following_url\": \"https://api.github.com/users/synacktraa/following{/other_user}\",\n    \"gists_url\": \"https://api.github.com/users/synacktraa/gists{/gist_id}\",\n    \"starred_url\": \"https://api.github.com/users/synacktraa/starred{/owner}{/repo}\",\n    \"subscriptions_url\": \"https://api.github.com/users/synacktraa/subscriptions\",\n    \"organizations_url\": \"https://api.github.com/users/synacktraa/orgs\",\n    \"repos_url\": \"https://api.github.com/users/synacktraa/repos\",\n    \"events_url\": \"https://api.github.com/users/synacktraa/events{/privacy}\",\n    \"received_events_url\": \"https://api.github.com/users/synacktraa/received_events\",\n    \"type\": \"User\",\n    \"user_view_type\": \"public\",\n    \"site_admin\": false,\n    \"name\": \"Harsh Verma\",\n    \"company\": null,\n    \"blog\": \"\",\n    \"location\": \"India\",\n    \"email\": null,\n    \"hireable\": null,\n    \"bio\": \"Hidden in the chaos is the element.\",\n    \"twitter_username\": null,\n    \"public_repos\": 45,\n    \"public_gists\": 6,\n    \"followers\": 48,\n    \"following\": 29,\n    \"created_at\": \"2021-10-05T17:57:09Z\",\n    \"updated_at\": \"2024-12-01T05:29:46Z\"\n}\n</code></pre> <p>As you can see, you only require a runtime instance and <code>.run_script</code> method to run the code.</p> <p>If you wish to persist the code as a uv project, you can use the <code>.create_project</code> method which can save you a lot of time as the third party dependencies are installed only once. Then you can utilise the <code>.run_project</code> method to run the project whenever you need.</p>"},{"location":"cookbooks/version-control-and-function-calling/","title":"Version Control & Function-Calling","text":"<p>Integrating Large Language Models (LLMs) with file system access introduces significant risks. AI models, while powerful, can unpredictably interact with files due to:</p> <ul> <li>Misinterpreting context</li> <li>Lacking understanding of file system consequences</li> <li>Potential hallucinations leading to destructive actions</li> </ul> <p>This cookbook presents a systematic approach to mitigating these risks by implementing version tracking and change management mechanisms, ensuring safe and controlled file system interactions with LLMs.</p>"},{"location":"cookbooks/version-control-and-function-calling/#installation-and-setup","title":"Installation and Setup","text":"<p>This cookbook requires the <code>litellm</code> library for function-call generation via the Groq provider.</p> <p>If you don't have an API key for Groq, you can get one at Groq Console.</p> <p><code>DirectoryTracker</code> component requires <code>git</code> for version control, you can download it from here</p> <pre><code>%pip install orchestr8[adapter] litellm\n\nimport os, getpass\n\ndef set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\nset_env(\"GROQ_API_KEY\")\n</code></pre> <pre><code>import json\nfrom typing import Any, Dict, List\n\nfrom litellm import completion\n\nINSTRUCTION = \"Complete user requests using the given functions.\"\n\ndef generate_function_call(request: str, functions: List[Dict[str, Any]]):\n    response = completion(\n        model=\"groq/llama3-groq-70b-8192-tool-use-preview\",\n        messages=[\n            {\"role\": \"system\", \"content\": INSTRUCTION},\n            {\"role\": \"user\", \"content\": request}\n        ],\n        tools=functions\n    )\n    tool_call = response.choices[0].message.tool_calls[0].function\n    if tool_call is None:\n        print(response.choices[0].message.content)\n        raise Exception(\"No function call found in the response.\")\n    return tool_call.name, json.loads(tool_call.arguments)\n</code></pre>"},{"location":"cookbooks/version-control-and-function-calling/#creating-a-tracker-instance","title":"Creating a tracker instance","text":"<p><code>DirectoryTracker</code> wraps Git commands to provide simple version control capabilities, including tracking changes, committing modifications, and undoing uncommitted changes. Supports large files through Git LFS when directory size exceeds a configurable limit.</p> <pre><code>import orchestr8 as o8\n\nfrom pathlib import Path\nfrom tempfile import tempdir\n\ndirectory = Path(tempdir) / \"orchestr8-tracking\" # We'll be working inside this directory\ndirectory.mkdir(exist_ok=True)\n\ntracker = o8.DirectoryTracker(path=directory)\n\nprint(f\"Listing {str(directory)}\")\nprint(tracker.shell.run(\"ls\")) # Returns None, because the directory is empty\n</code></pre> <p>Logs and Result</p> <pre><code>[DirectoryTracker] Initializing git repository\n[Shell] \u2699\ufe0f  || git init\n[DirectoryTracker] Staging all changes\n[Shell] \u2699\ufe0f  || git add .\n[DirectoryTracker] Creating an empty commit\n[Shell] \u2699\ufe0f  || git commit -m \"[Thu, Dec 05, 2024 11:08 AM] tracker init\" --allow-empty --no-verify\nListing /tmp/orchestr8-tracking\n[Shell] \u2699\ufe0f  || ls\nNone\n</code></pre>"},{"location":"cookbooks/version-control-and-function-calling/#creating-adapters-from-functions","title":"Creating adapters from functions","text":"<p>Creating adapters is as simple as defining a function and decorating it with <code>@adapt</code> decorator.</p> <pre><code>from pathlib import Path\n\nimport orchestr8 as o8\n\n@o8.adapt\ndef read_file(path: Path) -&gt; str:\n    \"\"\"\n    Read the contents of a file.\n\n    :param path: Path to the file\n    :return: File contents\n    \"\"\"\n    if not path.is_file():\n        raise FileNotFoundError(f\"File {path} not found.\")\n    return path.read_text()\n\n@o8.adapt\ndef write_file(path: Path, content: str, overwrite: bool = False) -&gt; None:\n    \"\"\"\n    Write content to a file.\n\n    :param path: Path to the file\n    :param content: Content to write\n    :param overwrite: Whether to overwrite the file if it exists\n    \"\"\"\n    if path.is_file() and not overwrite:\n        raise FileExistsError(\n            f\"File {path} already exists, set overwrite=True to overwrite it.\"\n        )\n    if not path.is_file():\n        path.touch()\n    path.write_text(content)\n\n\n@o8.adapt\ndef delete_file(path: Path) -&gt; None:\n    \"\"\"\n    Delete a file.\n\n    :param path: Path to the file\n    \"\"\"\n    if not path.is_file():\n        raise FileNotFoundError(f\"File {path} not found.\")\n    path.unlink()\n</code></pre>"},{"location":"cookbooks/version-control-and-function-calling/#generating-function-calls-and-tracking-changes","title":"Generating function-calls and tracking changes","text":"<p>Get ready for a version control adventure! We'll demonstrate how to safely interact with files using an AI assistant.</p> <pre><code>function_call = generate_function_call(\n    f\"Write 'Hello LLM' to {str(directory / 'new.txt')!r} file\",\n    functions=[write_file.openai_schema]\n)\nprint(function_call)\n</code></pre> <p>Result</p> <pre><code>('write_file', {'path': '/tmp/orchestr8-tracking/new.txt', 'content': 'Hello LLM'})\n</code></pre> <p>Let's validate and write our file into the directory.</p> <pre><code>write_file.validate_input(function_call[1])\n</code></pre> <p>Curious if our actions left any traces? Let's inspect the directory's status!</p> <pre><code>print(tracker.has_changes)\n</code></pre> <p>Logs and Result</p> <pre><code>[DirectoryTracker] Checking for uncommitted changes\n[Shell] \u2699\ufe0f  || git status --porcelain\nTrue\n</code></pre> <p>Time to peek inside our directory and see what's been created!</p> <pre><code>print(tracker.shell.run(\"ls\"))\n</code></pre> <p>Logs and Result</p> <pre><code>[Shell] \u2699\ufe0f  || ls\nnew.txt\n</code></pre> <p>Made a mistake? No worries! We'll show you how to roll back changes instantly.</p> <pre><code>tracker.undo()\n</code></pre> <p>Logs</p> <pre><code>[DirectoryTracker] Removing untracked files and directories\n[Shell] \u2699\ufe0f  || git clean -fd\n[DirectoryTracker] Resetting all tracked files to their last committed state\n[Shell] \u2699\ufe0f  || git reset --hard HEAD\n</code></pre> <p>Let's double-check that our undo worked perfectly.</p> <pre><code>print(tracker.shell.run(\"ls\"))\n</code></pre> <p>Logs and Result</p> <pre><code>[Shell] \u2699\ufe0f  || ls\nNone\n</code></pre> <p>Let's give it another shot and see the magic happen!</p> <pre><code>function_call = generate_function_call(\n    f\"Write bubble sort algorithm to {str(directory / 'sort.py')!r} file\",\n    functions=[write_file.openai_schema]\n)\nprint(function_call)\nwrite_file.validate_input(function_call[1])\n</code></pre> <p>Result</p> <pre><code>('write_file', {'path': '/tmp/orchestr8-tracking/sort.py', 'content': 'def bubble_sort(arr):\\n    n = len(arr)\\n\\n    for i in range(n):\\n        for j in range(0, n - i - 1):\\n            if arr[j] &gt; arr[j + 1]:\\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\\n\\n    return arr\\n\\narr = [64, 34, 25, 12, 22, 11, 90]\\nprint(bubble_sort(arr))'})\n</code></pre> <p>Peek inside the newly created file and marvel at the AI-generated code!</p> <pre><code>print(tracker.shell.run(\"cat\", \"sort.py\"))\n</code></pre> <p>Logs and Result</p> <pre><code>[Shell] \u2699\ufe0f  || cat sort.py\ndef bubble_sort(arr):\n    n = len(arr)\n\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n\n    return arr\n\narr = [64, 34, 25, 12, 22, 11, 90]\nprint(bubble_sort(arr))\n</code></pre> <p>Time to make our changes permanent with a commit!</p> <pre><code>tracker.commit(\"Added sort.py\")\n</code></pre> <p>Logs</p> <pre><code>[DirectoryTracker] Staging all changes\n[Shell] \u2699\ufe0f  || git add .\n[DirectoryTracker] Persisting uncommitted changes\n[Shell] \u2699\ufe0f  || git commit -m \"[Thu, Dec 05, 2024 11:21 AM] Added sort.py\"\n</code></pre> <p>Did our commit go through? Let's check the status!</p> <pre><code>print(tracker.has_changes)\n</code></pre> <p>Logs and Result</p> <pre><code>[DirectoryTracker] Checking for uncommitted changes\n[Shell] \u2699\ufe0f  || git status --porcelain\nFalse\n</code></pre> <p>Watch what happens when we ask the LLM to delete our carefully crafted file!</p> <pre><code>function_call = generate_function_call(\n    f\"Delete the {str(directory / 'sort.py')!r} file\",\n    functions=[delete_file.openai_schema]\n)\nprint(function_call)\ndelete_file.validate_input(function_call[1])\n</code></pre> <p>Result</p> <pre><code>('delete_file', {'path': '/tmp/orchestr8-tracking/sort.py'})\n</code></pre> <p>The tracker is vigilant! Let's see if it catches our file deletion.</p> <pre><code>print(tracker.has_changes)\n</code></pre> <p>Logs and Result</p> <pre><code>[DirectoryTracker] Checking for uncommitted changes\n[Shell] \u2699\ufe0f  || git status --porcelain\nTrue\n</code></pre> <p>Our directory's current state? Let's take a look!</p> <pre><code>print(tracker.shell.run(\"ls\"))\n</code></pre> <p>Logs and Result</p> <pre><code>[Shell] \u2699\ufe0f  || ls\nNone\n</code></pre> <p>No problem! We can easily restore our deleted file.</p> <pre><code>tracker.undo()\n</code></pre> <p>Logs</p> <pre><code>[DirectoryTracker] Removing untracked files and directories\n[Shell] \u2699\ufe0f  || git clean -fd\n[DirectoryTracker] Resetting all tracked files to their last committed state\n[Shell] \u2699\ufe0f  || git reset --hard HEAD\n</code></pre> <p>Confirming our file is back where it belongs!</p> <pre><code>print(tracker.shell.run(\"ls\"))\n</code></pre> <p>Logs and Result</p> <pre><code>[Shell] \u2699\ufe0f  || ls\nsort.py\n</code></pre> <p>Let's peek at our restored file one more time.</p> <pre><code>print(tracker.shell.run(\"cat\", \"sort.py\"))\n</code></pre> <p>Logs and Result</p> <pre><code>[Shell] \u2699\ufe0f  || cat sort.py\ndef bubble_sort(arr):\n    n = len(arr)\n\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n\n    return arr\n\narr = [64, 34, 25, 12, 22, 11, 90]\nprint(bubble_sort(arr))\n</code></pre> <p>Time to clean up our tracking!</p> <pre><code>tracker.delete()\nprint(tracker.is_tracking)\n</code></pre> <p>Logs and Result</p> <pre><code>[DirectoryTracker] Checking for uncommitted changes\n[Shell] \u2699\ufe0f  || git status --porcelain\n[DirectoryTracker] Deleting .git directory\n[Shell] \u2699\ufe0f  || rm -rf .git\nFalse\n</code></pre> <p>One final look at our directory.</p> <pre><code>print(tracker.shell.run(\"ls\"))\n</code></pre> <p>Logs and Result</p> <pre><code>[Shell] \u2699\ufe0f  || ls\nsort.py\n</code></pre>"},{"location":"tutorial/","title":"Overview","text":""},{"location":"tutorial/#installing-orchestr8","title":"Installing Orchestr8","text":"<p>Before we can start, you'll need to install Orchestr8 and dependencies. Come back here when you're done!</p>"},{"location":"tutorial/#quick-links","title":"Quick Links","text":"<ul> <li>Execution Runtime: Flexibly run projects and scripts across host and isolated environments</li> <li>Directory Tracker: Automate version control and file system change monitoring</li> <li>OAuth Flow: Simplify third-party service authentication processes</li> <li>Adapter: Generate code definition, schema in both standard and function-calling formats and validate inputs from different types</li> <li>Sandbox Client: Pull/build images, run containers and copy files from host to container.</li> <li>Shell: Execute commands across host machines and containers</li> </ul>"},{"location":"tutorial/adapter/","title":"Adapter","text":"<p>Orchestr8 comes with two types of adapters: <code>StructAdapter</code> and <code>FunctionAdapter</code>. These adapters allow you to generate schema in standard &amp; function-calling formats, extract code definition and validate input from Python or JsON object.</p>"},{"location":"tutorial/adapter/#adapt-decorator","title":"<code>@adapt</code> decorator","text":"<p>The <code>@adapt</code> decorator wraps both <code>StructAdapter</code> and <code>FunctionAdapter</code> and allows you to easily create adapters from functions or structured types such as Pydantic Model, TypedDict, dataclass, etc.</p> <pre><code>import orchestr8 as o8\nfrom typing import Literal\nfrom typing_extensions import TypedDict\n\n@o8.adapt\ndef search_web(\n    text: str,\n    backend: Literal['api', 'html', 'lite'] = 'api',\n):\n    \"\"\"\n    Search the web.\n\n    :param text: Text to search for\n    :param backend: Backend to use for retrieving results\n    \"\"\"\n    return f\"No results found for {text!r} in {backend!r} backend.\"\n\n@o8.adapt\nclass ProductInfo(BaseModel):\n    \"\"\"\n    Information about the product.\n\n    :param name: Name of the product\n    :param price: Price of the product\n    :param in_stock: If the product is in stock\n    \"\"\"\n    name: str\n    price: float\n    in_stock: bool\n</code></pre> <p>Working with adapter instance</p> <pre><code>print(search_web.name) # search_web\nprint(search_web.description) # Search the web.\n</code></pre> <p><code>search_web.definition</code></p> <p>Code definition</p> <pre><code>def search_web(\n    text: str,\n    backend: Literal['api', 'html', 'lite'] = 'api',\n):\n    \"\"\"\n    Search the web.\n\n    :param text: Text to search for\n    :param backend: Backend to use for retrieving results\n    \"\"\"\n    return f\"No results found for {text!r} in {backend!r} backend.\"\n</code></pre> <p><code>search_web.schema</code></p> <p>Standard Schema</p> <pre><code>{\n    'additionalProperties': False,\n    'properties': {\n        'text': {\n            'title': 'Text',\n            'type': 'string',\n            'description': 'Text to search for'\n        },\n        'backend': {\n            'default': 'api',\n            'enum': ['api', 'html', 'lite'],\n            'title': 'Backend',\n            'type': 'string',\n            'description': 'Backend to use for retrieving results'\n        }\n    },\n    'required': ['text'],\n    'type': 'object',\n    'description': 'Search the web.'\n}\n</code></pre> <p><code>search_web.openai_schema</code></p> <p>OpenAI Schema</p> <pre><code>{\n    \"type\": \"function\",\n    \"function\": {\n        'name': 'search_web',\n        'description': 'Search the web.',\n        'parameters': {\n            'additionalProperties': False,\n            'properties': {\n                'text': {\n                    'type': 'string',\n                    'description': 'Text to search for'\n                },\n                'backend': {\n                    'default': 'api',\n                    'enum': ['api', 'html', 'lite'],\n                    'type': 'string',\n                    'description': 'Backend to use for retrieving results'\n                }\n            },\n            'required': ['text'],\n            'type': 'object'\n        }\n    }\n}\n</code></pre> <p><code>search_web.anthropic_schema</code></p> <p>Anthropic Schema</p> <pre><code>{\n    \"type\": \"function\",\n    \"function\": {\n        'name': 'search_web',\n        'input_schema': {\n            'additionalProperties': False,\n            'properties': {\n                'text': {\n                    'type': 'string',\n                    'description': 'Text to search for'\n                },\n                'backend': {\n                    'default': 'api',\n                    'enum': ['api', 'html', 'lite'],\n                    'type': 'string',\n                    'description': 'Backend to use for retrieving results'\n                }\n            },\n            'required': ['text'],\n            'type': 'object'\n        }\n    }\n}\n</code></pre> <p><code>search_web.gemini_schema</code></p> <p>Gemini Schema</p> <pre><code>{\n    \"type\": \"function\",\n    \"function\": {\n        'name': 'search_web',\n        'parameters': {\n            'required': ['text'],\n            'type': 'object',\n            'properties': {\n                'text': {\n                    'description': 'Text to search for',\n                    'type': 'string'\n                },\n                'backend': {\n                    'description': 'Backend to use for retrieving results',\n                    'enum': ['api', 'html', 'lite'],\n                    'format': 'enum',\n                    'type': 'string'\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Validating inputs against the schema:</p> <pre><code>print(search_web.validate_input({\"text\": \"LLMs\", \"backend\": \"api\"}))\n# OR\nprint(search_web.validate_input('{\"text\": \"LLMs\", \"backend\": \"api\"}')) # JsON Input\n</code></pre> <p>Result</p> <pre><code>No results found for 'LLMs' in 'api' backend.\n</code></pre>"},{"location":"tutorial/adapter/#structadapter","title":"StructAdapter","text":"<p>A wrapper around pydantic's <code>TypeAdapter</code> for schema and definition generation with capability to validate input from python or JsON object.</p> <p>Structured types such as Pydantic Models, TypedDict, dataclasses, etc. are supported.</p> <p>Useful for schema-driven representations of complex types for use in function calling, serialization, and documentation contexts.</p> <p>Creating a <code>StructAdapter</code> instance is straightforward:</p> <pre><code>from typing_extensions import TypedDict\nfrom orchestr8.adapter import StructAdapter\n\nclass ProductInfo(TypedDict):\n    \"\"\"\n    Information about the product.\n\n    :param name: Name of the product\n    :param price: Price of the product\n    :param in_stock: If the product is in stock\n    \"\"\"\n    name: str\n    price: float\n    in_stock: bool\n\nadapter = StructAdapter(ProductInfo)\n</code></pre> <p>For more on how to use the instance, refer: @adapt decorator \"Working with adapter instance\" section.</p>"},{"location":"tutorial/adapter/#functionadapter","title":"FunctionAdapter","text":"<p>A specialized adapter for Python functions, extending StructAdapter to handle function-specific type hints.</p> <p>Creating a <code>FunctionAdapter</code> instance is straightforward:</p> <pre><code>from orchestr8.adapter import FunctionAdapter\n\ndef search_web(\n    text: str,\n    backend: Literal['api', 'html', 'lite'] = 'api',\n):\n    \"\"\"\n    Search the web.\n\n    :param text: Text to search for\n    :param backend: Backend to use for retrieving results\n    \"\"\"\n    return f\"No results found for {text!r} in {backend!r} backend.\"\n\nadapter = FunctionAdapter(search_web)\n</code></pre> <p>For more on how to use the instance, refer: @adapt decorator \"Working with adapter instance\" section.</p>"},{"location":"tutorial/directory-tracker/","title":"DirectoryTracker","text":"<p><code>DirectoryTracker</code> requires <code>git</code> for version control, you can download it from here</p> <p>This component wraps Git commands to provide simple version control capabilities, including tracking changes, committing modifications, and undoing uncommitted changes. It supports large files through Git LFS when directory size exceeds a configurable limit.</p> <p>Working with the <code>DirectoryTracker</code> class is straightforward:</p> <pre><code>import orchestr8 as o8\n\ntracker = o8.DirectoryTracker(\n    path=\"path/to/directory\", # Directory you want to track\n    use_lfs_after_size=200 # Use Git LFS if directory size exceeds 200MB\n)\n\n# Check if directory is being tracked\nprint(tracker.is_tracking)\n\n# Check for changes\nprint(tracker.has_changes)\n\n# Undo all uncommited changes if needed\ntracker.undo()\n\n# Committing changes\ntracker.commit(\"Added new files\")\n\n# Commit the changes and delete the .git directory\ntracker.delete(commit=True)\n\n# Initialize tracking explicitly\ntracker.initialize()\n</code></pre>"},{"location":"tutorial/execution-runtime/","title":"Execution Runtime","text":"<p>Execution runtime is one of the most interesting components in Orchestr8. It allows you to run Python scripts and created projects in the host or isolated virtual environments. It utilizes uv to provide a simple and efficient way to manage and run Python projects and scripts.</p> <p>There are two types of execution runtimes:</p> <ul> <li><code>ExecutionRuntime</code>: This runtime is used to run Python scripts and created projects in the host machine.</li> <li><code>IsolatedExecutionRuntime</code>: This runtime is used to run Python scripts and created projects in docker containers.</li> </ul>"},{"location":"tutorial/execution-runtime/#creating-projects","title":"Creating Projects","text":"<p>To create a project, you can use the <code>create_project</code> function. This function takes a python script, extracts its dependencies and creates a uv project. Created projects can be used through both host and isolated runtimes.</p> <pre><code>import orchestr8 as o8\n\no8.create_project(\n    \"/path/to/script_name.py\",\n    id=\"project_id\", # Not required, defaults to script name.\n    requirements=True,\n)\n</code></pre> <p>There are three values that can be passed to the <code>requirements</code> parameter:</p> <ul> <li><code>True</code>: Auto-generate requirements from the script. To know more refer generate_requirements function.</li> <li><code>[\"package==1.0.0\"]</code>: List of requirement strings.</li> <li><code>None</code>: Don't add any dependencies. (Default)</li> </ul> <p>All projects are created in the <code>~/.orchestr8/runtime/projects</code> directory.</p> <p>Listing ~/.orchestr8/runtime/projects/project_id</p> <pre><code>.venv\nmain.py\npyproject.toml\nrequirements.txt\nuv.lock\n</code></pre> <p><code>requirements.txt</code> is used by isolated runtimes to install dependencies in virtual environments inside containers</p>"},{"location":"tutorial/execution-runtime/#using-runtime-instances","title":"Using Runtime Instances","text":"<p>To create a runtime instance, you can use the <code>create_execution_runtime</code> function. This function takes an <code>isolate</code> parameter, which determines whether to use an isolated runtime or the host runtime.</p> <p>If you're already inside a container, it will default to using the host runtime</p> <pre><code>import orchestr8 as o8\n\nruntime = o8.create_execution_runtime(isolate=True)\n</code></pre> <p>You can also pass <code>python_tag</code> and <code>docker_config</code> parameters to customize the isolated runtime.</p> <p>Isolation requires docker, refer here for installation instructions</p> <p>Running a created project</p> <p>To run a created project, you can use the <code>run_project</code> method. It requires the <code>id</code> of the project.</p> <p>You can also pass arguments and environment variables to the project if needed.</p> <pre><code>output = runtime.run_project('project_id', '--param1', 'value1', env={\"ENV_VAR\": \"value\"})\n</code></pre> <p>Running a script</p> <p>You can run a script directly without needing to create a project using on-demand environments provided by <code>uv</code>. To do this, you can use the <code>run_script</code> method. It takes parameters required by both <code>create_project</code> function and <code>run_project</code> method.</p> <p>To know more about on-demand environments, refer uv docs</p> <pre><code>output = runtime.run_script(\n    'script1.py', '-p1', 'value1', requirements=True, env={\"ENV_VAR\": \"value\"}\n)\n</code></pre>"},{"location":"tutorial/execution-runtime/#executionruntime-host-based","title":"ExecutionRuntime (host-based)","text":"<p>Interface for running Python scripts and created projects in the host machine.</p> <pre><code>from orchestr8.execution_runtime import ExecutionRuntime\n\n# Create a host execution runtime instance\nruntime = ExecutionRuntime()\n\n# Run a script with auto-generated requirements\noutput = runtime.run_script('script1.py', '-p1', 'value1', requirements=True)\n\n# Run a script with pre-defined requirements\noutput = runtime.run_script('script2.py', requirements=[\"requests==2.25.1\"])\n\n# Run a created project\noutput = runtime.run_project('project_id', '--param1', 'value1')\n</code></pre>"},{"location":"tutorial/execution-runtime/#isolatedexecutionruntime","title":"IsolatedExecutionRuntime","text":"<p>Interface for running Python scripts and created projects in isolated environments.</p> <p>Isolation requires docker, refer here for installation instructions</p> <pre><code>from orchestr8.execution_runtime import IsolatedExecutionRuntime\n\n# Create an isolated execution runtime instance\nruntime = IsolatedExecutionRuntime(isolate=True, python_tag=\"3.10-alpine3.20\")\n\n# Run a script with auto-generated requirements\noutput = runtime.run_script('script1.py', '-p1', 'value1', requirements=True)\n\n# Run a script with pre-defined requirements\noutput = runtime.run_script('script2.py', requirements=[\"requests==2.25.1\"])\n\n# Run a created project\noutput = runtime.run_project('project_id', '--param1', 'value1')\n</code></pre>"},{"location":"tutorial/oauth-flow/","title":"OAuth Flow","text":"<p>OAuthFlow is a component that can be inherited to create authentication flows for connecting with services.</p> <ul> <li><code>OAuthFlow</code> requires <code>mkcert</code> for setting up local redirect server, refer here for installation instructions</li> </ul> <p>Here we will create a flow for connecting with discord.</p> <p>To create a flow, you can inherit the <code>OAuthFlow</code> class and implement the <code>get_authorization_url</code> and <code>get_token</code> methods.</p> <pre><code>import orchestr8 as o8\nimport requests\n\nclass DiscordOAuthFlow(o8.OAuthFlow):\n    \"\"\"Class for handling Discord OAuth2 flow.\"\"\"\n\n    @property\n    def auth_url(self) -&gt; str:\n        \"\"\"\n        Formatted Discord authorization URL for getting code.\n        \"\"\"\n        return (\n            f\"https://discord.com/api/oauth2/authorize\"\n            f\"?client_id={self.client_id}&amp;redirect_uri={self.quoted_redirect_url}\"\n            f\"&amp;response_type=code&amp;scope={self.user_scopes}\"\n        )\n\n    def _generate_access_token(self, code: str) -&gt; str:\n        \"\"\"\n        Generate an access token from the authorization code.\n\n        :param code: Authorization code from Discord.\n        :return: The access token.\n        \"\"\"\n        response = requests.post(\n            \"https://discord.com/api/oauth2/token\",\n            data={\n                'grant_type': 'authorization_code',\n                'code': code,\n                'redirect_uri': self.redirect_url,\n            },\n            headers={'Content-Type': 'application/x-www-form-urlencoded'},\n            auth=(self.client_id, self.client_secret)\n        )\n\n        if response.status_code != 200:\n            raise Exception(f\"Failed to obtain access token: {response.json()}\")\n\n        return response.json()['access_token']\n\ndiscord_flow = DiscordOAuthFlow(\n    client_id=\"&lt;client-id&gt;\",\n    client_secret=\"&lt;client-secret&gt;\",\n    user_scopes=\"identify messages.read\",\n)\naccess_token = discord_flow.authorize(timeout=30)\n</code></pre> <p>To generate client id and secret, refer discord oauth2 docs or directly go to discord developer portal</p>"},{"location":"tutorial/sandbox-client/","title":"Sandbox Client","text":"<p>SandboxClient is a component that wraps docker client to provide a simple interface for pulling/building images, running containers and copying files from host to container.</p> <p>Make sure you have <code>docker</code> installed on your machine, refer here for installation instructions.</p> <pre><code>sandbox_client = o8.SandboxClient()\n\n# Pulling an image\n# If you don't pass the dockerfile, it will try to pull the image from docker hub\nsandbox_client.build_image(\"ubuntu:latest\")\n\n# Building an image from a dockerfile\nsandbox_client.build_image(\"my-image:my-tag\", dockerfile=\"/path/to/Dockerfile\")\n\n# Running a container\ncontainer = sandbox_client.run_container(\"ubuntu:latest\", detach=True, remove=True)\n\n# Copying files from host to container\nsandbox_client.copy_path_to_container(container.id, \"/path/on/host\", \"/path/on/container\")\n</code></pre>"},{"location":"tutorial/shell/","title":"Shell","text":"<p>Shell component is prettry self-explanatory. It allows you to run commands in host machine or inside a container.</p> <p>There are two types of shell:</p> <ul> <li><code>Shell</code>: This shell is used to run commands in host machine.</li> <li><code>IsolatedShell</code>: This shell is used to run commands inside a container.</li> </ul>"},{"location":"tutorial/shell/#using-shell-host-based","title":"Using Shell (host-based)","text":"<pre><code>import orchestr8 as o8\n\n# Initialize the shell\nshell = o8.Shell(workdir=\"/path/to/directory\")\n\n# Run command\nprint(shell.run(\"echo\", \"Hello from shell!\"))\n\n# Stream run command\nfor line in shell.stream(\"ls\", \"-l\"):\n    print(line)\n</code></pre>"},{"location":"tutorial/shell/#using-isolatedshell","title":"Using IsolatedShell","text":"<p>Isolation requires docker, refer here for installation instructions</p> <pre><code>import orchestr8 as o8\n\n# Create a detached container\ncontainer = o8.SandboxClient().run_container(\n    \"ubuntu:22.04\", detach=True, remove=True\n)\n\n# Initialize the shell\nshell = o8.IsolatedShell(\n    container=container, workdir=\"/path/to/directory\"\n)\n\n# Run command\nprint(shell.run(\"echo\", \"Hello from shell!\"))\n\n# Stream run command\nfor line in shell.stream(\"ls\", \"-l\"):\n    print(line)\n</code></pre>"}]}